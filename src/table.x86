# SPDX-FileCopyrightText: Authors of TuxNES
# SPDX-License-Identifier: GPL-2.0-or-later

# Description: Translation tables for 6502 to x86 dynamic recompiler

# This is the translation table for converting 6502 code into native code
# for x86 processors.  I have used the GNU standard for the representation
# of operands, which is: source,destination.  Be aware that Intel uses the
# opposite ordering in their documentation (destination precedes source).
#
# I have adopted the following register usage conventions:
#
#      A -> %eax            Carry flag -> %ebp
#      X -> %ecx     Zero & Sign flags -> %edi
#      Y -> %edx           Cycle count -> %esi
#
# The stack pointer and remaining flags are stored in memory.  The 6502
# program counter is loaded into %ebx when a branch occurs; at all other
# times, %ebx is used to hold various temporary values.  The carry flag
# is stored by setting %ebp to a nonzero value.  The %esi register is
# incremented to represent the 6502 cycle count.
#
# %edi is used to store the sign and zero flags.  This is usually done by
# sign-extending the result of arithmetic operations into %edi.  The
# equivalence branch instructions check the lower 8 bits of %edi against
# zero, and the sign branch instructions check bit 8 (0x100) of %edi.  While
# in many cases it would be sufficient to check only bit 7 to determine
# the sign, some 6502 instructions (such as BIT) can set the sign and zero
# flags independently, so a mechanism must be provided to accommodate this.
# Sign extension unfortunately is relatively slow (3 cycles) on a Pentium
# processor.  An alternative would be to store the sign and zero flags in
# separate memory locations, but as this would also require additional CPU
# cycles to read/write memory, I see little advantage in this approach,
# especially considering that the sign-extension can be precomputed for
# immediate data, thus eliminating the 3-cycle penalty for most data load
# operations.
#
# This file consists of a substitution table for replacing 6502 code with
# native equivalents.  The format is as follows:
#
# (6502 instruction bytes),length:  (native instruction bytes) /
#
# Each statement may span multiple lines and is terminated with a single
# slash mark.  All values are in hexadecimal.  The compdata.c program parses
# this file and compiles it into a binary search tree which is then linked
# into the final executable.  Anything following a # mark (such as this text)
# is ignored by the compiler.
#
# The source bytes may contain a pattern to be matched using an and-mask,
# which follows the instruction byte and a slash.  For example:
# 80/80 matches any value with the high bit set, 00/01 matches any even
# number, and 00/00 matches anything.
#
# The compiler can evaluate the following expressions in generating the
# translated code:
#
# [B+n] Byte at SRC+n, where SRC is the address of the 6502 instruction
# [C+n] Bitwise compliment of byte at SRC+n
# [W+n] 16-bit word at SRC+n
# [E+n] Byte at PC+n sign-extended to doubleword
# [Z+n] Zero Page Pointer to addr byte at SRC+n
# [A+n] Absolute address (word16 at SRC+n -> RAM address)
# [R+n] Relative branch address (byte at SRC+n converted to target address)
# [P+n] Current 6502 program counter +n (word16)
# [X+n] Precalculated remap table address for word16 at SRC+n
# [D+n] Destination address of translated code +n
# [>+n] Cycle count adjust (+1) for branch at SRC+n
# [V]   V-flag storage location
# [F]   Other flags storage location (process status register)
# [S]   Stack Pointer
# [T]   Top of stack (lowest address)
# [L]   Base of RAM (lowest address)
# [M]   Base address of mapper table
# [N]   Relative address of NMI/IRQ/refresh handler
# [I]   Relative address of input handler
# [O]   Relative address of output handler
# [U]   Relative address of unresolved address handler
# [Y]   Relative address of remapper
# [!]   Stop translating
# [^]   Insert breakpoint/trap
#
# To write to an output register, the generated code should put the location
# into %ebx and the value to write in %eax, and call [O].  (The compiler will
# replace [O] with the proper address.)  To read an input register, place the
# location into %ebx and call [I].  The value is returned in %edi.  For
# writes into the ROM area, call [Y] to pass these values to the mapper.
#
# Reads of memory are redirected thru the mapper table.  This table consists
# of 16 entries, each representing 4K of memory in the 6502 address space
# and containing a pointer to the actual memory location where the data can
# be found.  This table is used to emulate the function of the mapper chips
# found in many game cartridges.
#
# To execute a jump to a 6502 address, load the address into %ebx and jump
# to [U].  Also load the address of the operand of the jump instruction into
# %esp-4; that is, put it on top of the stack without modifying the stack
# pointer.  The Update function will translate any new code if necessary and
# resolve the 6502 target address into a native 32-bit address.  It will
# then use the value at %esp-4 to update the jump instruction to point to
# the new location.  For indirect jumps which can not be predicted, zero
# should be loaded into %esp-4, and the address will not be modified.  This
# may also be necessary if the target of the jump is swapped by the mapper.
#
# The %esi register is constantly incremented to reflect the 6502 cycle count.
# When this register exceeds 0xffffffff and wraps around, the program should
# jump to the NMI function [N].  This is done whether interrupts are enabled
# or not - this function updates the screen display and then generates a
# vblank NMI if appropriate.  In some cases the interrupt to be generated is
# actually an IRQ and not an NMI, but these are treated the same; the [N]
# function will determine which interrupt to generate, if any. (see x86.S)
#
# Note that this file is parsed beginning to end, with later statements
# overriding previous ones.  Therefore, general cases are defined first, and
# special cases last.
#
# Thanks to Matt Ghio for assembler coding help.
#
# Basic NES Memory Map:
#
# 0000-0800 - NES internal RAM
# 2000-2007 - I/O register area 1 (see io.c)
# 4000-4015 - I/O register area 2 (see io.c)
# 6000-7fff - Nonvolatile RAM for save data
# 8000-ffff - Reads ROM, writes output to mapper (see mapper.c)


# 00 - BRK
00,1:
	50                      # pushl  %eax
	a1 [S]                  # movl   STACKPTR,%eax
	bb [P+2]                # movl   $[P+2],%ebx
	88 38                   # movb   %bh,(%eax)
	fe c8                   # decb   %al
	88 18                   # movb   %bl,(%eax)
	fe c8                   # decb   %al
	8b 1d [F]               # movl   FLAGS,%ebx
	83 e3 0c                # andl   $0x0c,%ebx
	83 c5 ff                # addl   $-1,%ebp
	83 d3 00                # adcl   $0,%ebx
	89 fd                   # movl   %edi,%ebp
	d1 ed                   # shrl   %ebp
	81 e5 80 00 00 00       # andl   $0x80,%ebp
	09 dd                   # orl    %ebx,%ebp
	31 db                   # xorl   %ebx,%ebx
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	0f 94 c3                # setz   %bl
	8d 6c 5d 00             # leal   (%ebp,%ebx,2),%ebp
	8b 1d [V]               # movl   VFLAG,%ebx
	81 c3 80 00 00 00       # addl   $0x80,%ebx
	81 c3 00 ff ff ff       # addl   $-256,%ebx
	19 db                   # sbbl   %ebx,%ebx
	83 e3 40                # andl   $0x40,%ebx
	09 eb                   # orl    %ebp,%ebx
	83 e5 01                # andl   $0x1,%ebp
	83 cb 30                # orl    $0x30,%ebx
	83 0d [F] 04            # orl    $0x04,FLAGS
	88 18                   # movb   %bl,(%eax)
	fe c8                   # decb   %al
	a2 [S]                  # movb   %al,STACKPTR
	58                      # popl   %eax
	83 c6 07                # addl   $7,%esi
	bb [M]                  # movl   $MAPTABLE,%ebx
	8b 5b 3c                # movl   0x3c(%ebx),%ebx
	0f b7 9b fe ff 00 00    # movzwl 0xfffe(%ebx),%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	[!]                     #  -STOP-
	/
# 01 - ORA - (Indirect,X)
01,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	31 db                   # xorl   %ebx,%ebx
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	66 8b 9f [L]            # movw   RAM(%edi),%bx

# FIXME - trap I/O
	8d bb 00 e0 ff ff       # leal   0xffffe000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	8d 76 06                # leal   6(%esi),%esi
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx
	0a 04 1f                # orb    (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 02 - (bad)
# 03 - (bad)
# 04 - (bad)
# 05 - ORA - Zero Page
05,2:
	0b 05 [Z+1]             # orl    ZP,%eax
	83 c6 03                # addl   $0x3,%esi
	0f be f8                # movsbl %al,%edi
	/
# 06 - ASL - Zero Page
06,2:
	31 db                   # xorl   %ebx,%ebx
	8a 1d [Z+1]             # movb   ZP,%bl
	00 db                   # addb   %bl,%bl
	8d 76 05                # leal   0x5(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	88 1d [Z+1]             # movb   %bl,ZP
	0f be fb                # movsbl %bl,%edi
	/
# 07 - (bad)
# 08 - PHP
08,1:
	8b 1d [F]               # movl   FLAGS,%ebx
	83 e3 0c                # andl   $0x0c,%ebx
	83 c5 ff                # addl   $-1,%ebp
	83 d3 00                # adcl   $0,%ebx
	89 fd                   # movl   %edi,%ebp
	d1 ed                   # shrl   %ebp
	81 e5 80 00 00 00       # andl   $0x80,%ebp
	09 dd                   # orl    %ebx,%ebp
	31 db                   # xorl   %ebx,%ebx
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	0f 94 c3                # setz   %bl
	8d 6c 5d 00             # leal   (%ebp,%ebx,2),%ebp
	8b 1d [V]               # movl   VFLAG,%ebx
	81 c3 80 00 00 00       # addl   $0x80,%ebx
	81 c3 00 ff ff ff       # addl   $-256,%ebx
	19 db                   # sbbl   %ebx,%ebx
	83 e3 40                # andl   $0x40,%ebx
	09 eb                   # orl    %ebp,%ebx
	83 cb 30                # orl    $0x30,%ebx
	8b 2d [S]               # movl   STACKPTR,%ebp
	88 5d 00                # movb   %bl,(%ebp)
	fe 0d [S]               # decb   STACKPTR
	83 e3 01                # andl   $0x1,%ebx
	89 dd                   # movl   %ebx,%ebp
	83 c6 03                # addl   $3,%esi
	/
# 09 - ORA - Immediate
09,2:
	83 c8 [B+1]             # orl    $[B+1],%eax
	83 c6 02                # addl   $0x2,%esi
	0f be f8                # movsbl %al,%edi
	/
# 0a - ASL - Accumulator
0a,1:
	00 c0                   # addb   %al,%al
	8d 76 02                # leal   0x2(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	/
# 0b - (bad)
# 0c - (bad)
# 0d - ORA - Absolute
0d,3:
	8b 1d [X+1]             # movl   XLATADDR,%ebx
	83 c6 04                # addl   $0x4,%esi
	0a 83 [W+1] 00 00       # orb    ADDR(%ebx),%al
	0f be f8                # movsbl %al,%edi
	/
# 0e - ASL - Absolute
0e,3:
# Warning - doesn't check mapper
	31 db                   # xorl   %ebx,%ebx
	8a 1d [A+1]             # movb   ADDR,%bl
	00 db                   # addb   %bl,%bl
	8d 76 06                # leal   0x6(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	88 1d [A+1]             # movb   %bl,ADDR
	0f be fb                # movsbl %bl,%edi
	/
# 0f - (bad)
# 10 - BPL
10,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 00 01 00 00       # testl  $0x100,%edi
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 84 [U]               # je     U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 11 - ORA - (Indirect),Y
11,2:
	31 db                   # xorl   %ebx,%ebx
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	66 8b 1d [Z+1]          # movw   ZP,%bx
	8d 3c 1a                # leal   (%edx,%ebx,1),%edi
	8d 1c 1a                # leal   (%edx,%ebx,1),%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	8d 76 05                # leal   0x5(%esi),%esi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi

# FIXME - trap I/O
	81 fb 00 60 00 00       # cmpl   $0x6000,%ebx
	73 09                   # jae    +9
	81 fb 00 20 00 00       # cmpl   $0x2000,%ebx
	72 01                   # jb     +1
	[^]                     # int3

	0a 04 1f                # orb    (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 12 - (bad)
# 13 - (bad)
# 14 - (bad)
# 15 - ORA - Zero Page,X
15,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	83 c6 04                # addl   $0x4,%esi
	0b 83 [L]               # orl    RAM(%ebx),%eax
	0f be f8                # movsbl %al,%edi
	/
# 16 - ASL - Zero Page,X
16,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	31 db                   # xorl   %ebx,%ebx
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	8d 76 06                # leal   6(%esi),%esi
	8a 9f [L]               # movb   RAM(%edi),%bl
	00 db                   # addb   %bl,%bl
	19 ed                   # sbbl   %ebp,%ebp
	88 9f [L]               # movb   %bl,RAM(%edi)
	0f be fb                # movsbl %bl,%edi
	/
# 17 - (bad)
# 18 - CLC
18,1:
	31 ed                   # xorl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# 19 - ORA - Absolute,Y
19,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	8d ba [W+1] 00 00       # leal   ADDR(%edx),%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx
	0a 04 3b                # orb    (%ebx,%edi,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 1a - (bad)
# 1b - (bad)
# 1c - (bad)
# 1d - ORA - Absolute,X
1d,3:
# FIXME - cycle count wrong
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	8d b9 [W+1] 00 00       # leal   ADDR(%ecx),%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx
	0a 04 3b                # orb    (%ebx,%edi,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 1e - ASL - Absolute,X
1e,3:
# warning: assumes RAM target; doesn't check ROM mapper or ffff->0000 overflow
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c6 07                # addl   $0x7,%esi        (cycle count +7)
	d0 a1 [A+1]             # shlb   [A+1](%ecx)
	19 ed                   # sbbl   %ebp,%ebp        (saves carry flag)
	0f be b9 [A+1]          # movsbl [A+1](%ecx),%edi (saves other flags)
	/
# 1f - (bad)
# 20 - JSR
20,3:
	bb [P+2]                # movl   $[P+2],%ebx
	50                      # pushl  %eax
	a1 [S]                  # movl   STACKPTR,%eax
	88 38                   # movb   %bh,(%eax)
	fe c8                   # decb   %al
	88 18                   # movb   %bl,(%eax)
	fe c8                   # decb   %al
	a2 [S]                  # movb   %al,STACKPTR
	58                      # popl   %eax
	bb [W+1] 00 00          # movl   $0000[W+1],%ebx
	83 c6 06                # addl   $6,%esi
	0f 89 [N]               # jns    NMI
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]                     #  -STOP-
# It's fairly common for 6502 code to follow a JSR with parameter data,
# so there's a chance that what follows is not executable code, in which
# case translation should stop after the JSR.
	/
# 21 - AND - (Indirect,X)
# 22 - (bad)
# 23 - (bad)
# 24 - BIT - Zero Page
24,2:
	0f be 3d [Z+1]          # movsbl ZP,%edi
	0d 00 01 00 00          # orl    $0x100,%eax
	8d 1c 3f                # leal   (%edi,%edi,1),%ebx
	81 e3 80 00 00 00       # andl   $0x80,%ebx
	89 1d [V]               # movl   %ebx,VFLAG
	21 c7                   # andl   %eax,%edi
	83 c6 03                # addl   $3,%esi
	/
# 25 - AND - Zero Page
25,2:
	23 05 [Z+1]             # andl   ZP,%eax
	83 c6 03                # addl   $3,%esi
	0f be f8                # movsbl %al,%edi
	/
# 26 - ROL - Zero Page
26,2:
	83 c5 ff                # addl   $0xffffffff,%ebp
	d0 15 [Z+1]             # rclb   ZP
	8d 76 05                # leal   5(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	0f be 3d [Z+1]          # movsbl ZP,%edi
	/
# 27 - (bad)
# 28 - PLP
28,1:
	8b 1d [S]               # movl   STACKPTR,%ebx
	fe c3                   # incb   %bl
	88 1d [S]               # movb   %bl,STACKPTR
	8b 2b                   # movl   (%ebx),%ebp
	89 2d [F]               # movl   %ebp,FLAGS
	8d 7c 2d 00             # leal   (%ebp,%ebp,1),%edi
	81 e7 80 00 00 00       # andl   $0x80,%edi
	89 3d [V]               # movl   %edi,VFLAG
	83 f5 02                # xorl   $0x2,%ebp
	8d 7c 2d 00             # leal   (%ebp,%ebp,1),%edi
	81 e7 04 01 00 00       # andl   $0x104,%edi
	83 e5 01                # andl   $0x1,%ebp
	83 c6 04                # addl   $4,%esi
	/
# 29 - AND - Immediate
29,2:
	25 [B+1] 00 00 00       # andl   $0x000000[B+1],%eax
	83 c6 02                # addl   $0x2,%esi
	0f be f8                # movsbl %al,%edi
#Alternate form does same thing:
#	25 [B+1] 00 00 00       # andl   $0x000000[B+1],%eax
#	83 c0 80                # addl   $0xffffff80,%eax
#	83 c6 02                # addl   $0x2,%esi
#	83 f0 80                # xorl   $0xffffff80,%eax
#	89 c7                   # movl   %eax,%edi
	/
# 2a - ROL - Accumulator
2a,1:
	83 c5 ff                # addl   $0xffffffff,%ebp
	d0 d0                   # rclb   %al
	8d 76 02                # leal   2(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	/
# 2b - (bad)
# 2c - BIT - Absolute
2c,3:
	8b 1d [X+1]             # movl   XADDRMAP,%ebx
	0d 00 01 00 00          # orl    $0x100,%eax
	0f be bb [W+1] 00 00    # movsbl ADDR(%ebx),%edi
	8d 1c 3f                # leal   (%edi,%edi,1),%ebx
	81 e3 80 00 00 00       # andl   $0x80,%ebx
	89 1d [V]               # movl   %ebx,VFLAG
	21 c7                   # andl   %eax,%edi
	83 c6 04                # addl   $4,%esi
	/
# 2d - AND - Absolute
2d,3:
	8b 1d [X+1]             # movl   XMAPADDR,%ebx
	83 c6 04                # addl   $0x4,%esi
	22 83 [W+1] 00 00       # andb   ADDR(%ebx),%al
	0f be f8                # movsbl %al,%edi
	/
# 2e - ROL - Absolute
2e,3:
#warning - assumes ram target, doesn't check mapper
	83 c5 ff                # addl   $0xffffffff,%ebp
	d0 15 [A+1]             # rclb   ADDR
	8d 76 06                # leal   6(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	0f be 3d [A+1]          # movsbl ADDR,%edi
	/
# 2f - (bad)
# 30 - BMI
30,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 00 01 00 00       # testl  $0x100,%edi
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 31 - AND - (Indirect),Y
31,2:
	31 db                   # xorl   %ebx,%ebx
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	66 8b 1d [Z+1]          # movw   [Z+1],%bx
	01 d3                   # addl   %edx,%ebx

# FIXME - trap I/O
	8d bb 00 e0 ff ff       # leal   0xffffe000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx
	83 c6 05                # addl   $0x5,%esi
	22 04 3b                # andb   (%ebx,%edi,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 32 - (bad)
# 33 - (bad)
# 34 - (bad)
# 35 - AND - Zero Page,X
35,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	83 c6 04                # addl   $0x4,%esi
	23 83 [L]               # andl   RAM(%ebx),%eax
#	                        #andb..?
	0f be f8                # movsbl %al,%edi
	/
# 36 - ROL - Zero Page,X
36,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	d0 93 [L]               # rclb   RAM(%ebx)
	8d 76 06                # leal   6(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	/
# 37 - (bad)
# 38 - SEC
38,1:
	83 cd ff                # orl    $-1,%ebp
	83 c6 02                # addl   $2,%esi
	/

# 39 - AND - Absolute,Y
39,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	c1 eb 0c                # shrl   $0xc,%ebx
	8d ba [W+1] 00 00       # leal   ADDR(%edx),%edi
	83 c6 04                # addl   $0x4,%esi
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx
	22 04 3b                # andb   (%ebx,%edi,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 3a - (bad)
# 3b - (bad)
# 3c - (bad)
# 3d - AND - Absolute,X
3d,3:
# FIXME - cycle count wrong
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	c1 eb 0c                # shrl   $0xc,%ebx
	8d b9 [W+1] 00 00       # leal   ADDR(%ecx),%edi
	83 c6 04                # addl   $0x4,%esi
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx
	22 04 3b                # andb   (%ebx,%edi,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 3e - ROL - Absolute,X
3e,3:
# warning: assumes RAM target; doesn't check ROM mapper!
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c5 ff                # addl   $0xffffffff,%ebp
	8d 76 07                # leal   7(%esi),%esi
	d0 91 [A+1]             # rclb   ADDR(%ecx)
	19 ed                   # sbbl   %ebp,%ebp       (saves carry flag)
	0f be b9 [A+1]          # movsbl ADDR(%ecx),%edi (saves other flags)
	/
# 3f - (bad)
# 40 - RTI
40,1:
	8b 1d [S]               # movl   STACKPTR,%ebx
	fe c3                   # incb   %bl
	8b 2b                   # movl   (%ebx),%ebp
	89 2d [F]               # movl   %ebp,FLAGS
	8d 7c 2d 00             # leal   (%ebp,%ebp,1),%edi
	81 e7 80 00 00 00       # andl   $0x80,%edi
	89 3d [V]               # movl   %edi,VFLAG
	83 f5 02                # xorl   $0x2,%ebp
	8d 7c 2d 00             # leal   (%ebp,%ebp,1),%edi
	81 e7 04 01 00 00       # andl   $0x104,%edi
	83 e5 01                # andl   $0x1,%ebp
	fe c3                   # incb   %bl
	8a 2b                   # movb   (%ebx),%ch
	fe c3                   # incb   %bl
	8a 33                   # movb   (%ebx),%dh
	88 1d [S]               # movb   %bl,STACKPTR
	31 db                   # xorl   %ebx,%ebx
	86 eb                   # xchgb  %ch,%bl
	86 f7                   # xchgb  %dh,%bh
	83 c6 06                # addl   $6,%esi
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# 41 - EOR - (Indirect,X)
# 42 - (bad)
# 43 - (bad)
# 44 - (bad)
# 45 - EOR - Zero Page
45,2:
	33 05 [Z+1]             # xorl   Z,%eax
	83 c6 03                # addl   $0x3,%esi
	0f be f8                # movsbl %al,%edi
	/
# 46 - LSR - Zero Page
46,2:
	31 db                   # xorl   %ebx,%ebx
	8a 1d [Z+1]             # movb   ZP,%bl
	d0 eb                   # shrb   %bl
	8d 76 05                # leal   0x5(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	88 1d [Z+1]             # movb   %bl,ZP
	89 df                   # movl   %ebx,%edi
	/
# 47 - (bad)
# 48 - PHA
48,1:
	8b 1d [S]               # movl   STACKPTR,%ebx
	88 03                   # movb   %al,(%ebx)
	fe cb                   # decb   %bl
	88 1d [S]               # movb   %bl,STACKPTR
	83 c6 03                # addl   $3,%esi
	/
# 49 - EOR - Immediate
49,2:
	35 [E+1]                # xorl   $[E+1],%eax
	83 c6 02                # addl   $0x2,%esi
	0f be f8                # movsbl %al,%edi
	/
# 4a - LSR - Accumulator
4a,1:
	d1 e8                   # shrl   %eax
	19 ed                   # sbbl   %ebp,%ebp
	83 e0 7f                # andl   $0x7f,%eax
	8d 76 02                # leal   0x2(%esi),%esi
	89 c7                   # movl   %eax,%edi
	/
# 4b - (bad)
# 4c - JMP - Absolute
4c,3:
	83 c6 03                # addl   $3,%esi
	bb [W+1] 00 00          # movl   $0000[W+1],%ebx
	0f 89 [N]               # jns    NMI
	81 fb [P]               # cmpl   $[P],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	31 f6                   # xorl   %esi,%esi
	e9 [N]                  # jmp    NMI
	[!]
	/
# 4d - EOR - Absolute
4d,3:
	8b 1d [X+1]             # movl   XMAPADDR,%ebx
	83 c6 04                # addl   $0x4,%esi
	32 83 [W+1] 00 00       # xorb   ADDR(%ebx),%al
	0f be f8                # movsbl %al,%edi
	/
# 4e - LSR - Absolute
4e,3:
# Warning: read-modify-write operation assumes RAM target, does not check mapper table
	8b 1d [A+1]             # movl   ADDR,%ebx
	d1 eb                   # shrl   %ebx
	19 ed                   # sbbl   %ebp,%ebp
	83 e3 7f                # andl   $0x7f,%ebx
	8d 76 06                # leal   6(%esi),%esi
	88 1d [A+1]             # movb   %bl,ADDR
	89 df                   # movl   %ebx,%edi
	/
# 4f - (bad)
# 50 - BVC
50,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	8b 1d [V]               # movl   VFLAG,%ebx
	81 c3 80 00 00 00       # addl   $0x80,%ebx
	f7 c3 00 ff ff ff       # testl  $-256,%ebx
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 84 [U]               # je     U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 51 - EOR - (Indirect),Y
51,2:
	31 db                   # xorl   %ebx,%ebx
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	66 8b 1d [Z+1]          # movw   [Z+1],%bx
	8d 76 05                # leal   0x5(%esi),%esi
	8d 3c 1a                # leal   (%edx,%ebx,1),%edi
	c1 ef 0c                # shrl   $0xc,%edi
	8d 1c 1a                # leal   (%edx,%ebx,1),%ebx

# FIXME - trap I/O
	81 fb 00 60 00 00       # cmpl   $0x6000,%ebx
	73 09                   # jae    +9
	81 fb 00 20 00 00       # cmpl   $0x2000,%ebx
	72 01                   # jb     +1
	[^]                     # int3

	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	32 04 3b                # xorb   (%ebx,%edi,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 52 - (bad)
# 53 - (bad)
# 54 - (bad)
# 55 - EOR - Zero Page,X
55,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	83 c6 04                # addl   $0x4,%esi
	33 83 [L]               # xorl   RAM(%ebx),%eax
	0f be f8                # movsbl %al,%edi
	/
# 56 - LSR - Zero Page,X
56,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	31 db                   # xorl   %ebx,%ebx
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	8d 76 06                # leal   0x6(%esi),%esi
	8a 9f [L]               # movb   RAM(%edi),%bl
	d0 eb                   # shrb   %bl
	19 ed                   # sbbl   %ebp,%ebp
	88 9f [L]               # movb   %bl,RAM(%edi)
	89 df                   # movl   %ebx,%edi
	/
# 57 - (bad)
# 58 - CLI
58,1:
	80 25 [F] fb            # andb   $0xfb,FLAGS
	83 c6 02                # addl   $2,%esi
	/
# 59 - EOR - Absolute,Y
59,3:
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	8d ba [W+1] 00 00       # leal   ADDR(%edx),%edi
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $0x4,%esi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	32 04 1f                # xorb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 5a - (bad)
# 5b - (bad)
# 5c - (bad)
# 5d - EOR - Absolute,X
5d,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	8d b9 [W+1] 00 00       # leal   ADDR(%ecx),%edi
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $0x4,%esi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	32 04 1f                # xorb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 5e - LSR - Absolute,X
5e,3:
# Warning- Doesn't check mapper
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	31 db                   # xorl   %ebx,%ebx
	8a 99 [A+1]             # movb   RAM(%ecx),%bl
	d0 eb                   # shrb   %bl
	8d 76 07                # leal   0x7(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	88 99 [A+1]             # movb   %bl,RAM(%ecx)
	89 df                   # movl   %ebx,%edi
	/
# 5f - (bad)
# 60 - RTS
60,1:
	31 db                   # xorl   %ebx,%ebx
	50                      # pushl  %eax
	a1 [S]                  # movl   STACKPTR,%eax
	fe c0                   # incb   %al
	8a 18                   # movb   (%eax),%bl
	fe c0                   # incb   %al
	8a 38                   # movb   (%eax),%bh
	a2 [S]                  # movb   %al,STACKPTR
	58                      # popl   %eax
	83 c3 01                # addl   $1,%ebx
	83 c6 06                # addl   $6,%esi
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	[!]                     #  end of function; stop translating
	/
# 61 - ADC - (Indirect,X)
61,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	0f b7 bf [L]            # movzwl RAM(%edi),%edi
	89 fb                   # movl   %edi,%ebx

# FIXME - trap I/O
	81 fb 00 60 00 00       # cmpl   $0x6000,%ebx
	73 09                   # jae    +9
	81 fb 00 20 00 00       # cmpl   $0x2000,%ebx
	72 01                   # jb     +1
	[^]                     # int3

	c1 ef 0c                # shrl   $0xc,%edi
	83 c5 ff                # addl   $0xffffffff,%ebp
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 06                # leal   0x6(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# 62 - (bad)
# 63 - (bad)
# 64 - (bad)
# 65 - ADC - Zero Page
65,2:
	0f be c0                # movsbl %al,%eax
	0f be 1d [Z+1]          # movsbl ZP,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	11 d8                   # adcl   %ebx,%eax
	8d 76 03                # leal   3(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# 66 - ROR - Zero Page
66,2:
	31 db                   # xorl   %ebx,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	8a 1d [Z+1]             # movb   ZP,%bl
	d0 db                   # rcrb   %bl
	8d 76 05                # leal   5(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	88 1d [Z+1]             # movb   %bl,ZP
	0f be fb                # movsbl %bl,%edi
	/
# 67 - (bad)
# 68 - PLA
68,1:
	a1 [S]                  # movl   STACKPTR,%eax
	fe c0                   # incb   %al
	a2 [S]                  # movb   %al,STACKPTR
	8a 00                   # movb   (%eax),%al
	0f be f8                # movsbl %al,%edi
	83 c6 04                # addl   $4,%esi
	/
# 69 - ADC - Immediate
69,2:
	83 c5 ff                # addl   $0xffffffff,%ebp
	0f be c0                # movsbl %al,%eax
	83 d0 [B+1]             # adcl   $[B+1],%eax
	8d 76 02                # leal   0x2(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# 6a - ROR - Accumulator
6a,1:
	83 c5 ff                # addl   $0xffffffff,%ebp
	d0 d8                   # rcrb   %al
	8d 76 02                # leal   0x2(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	/
# 6b - (bad)
# 6c - JMP - Indirect
6c,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	83 c6 05                # addl   $0x5,%esi
	8b 9b [W+1] 00 00       # movl   ADDR(%ebx),%ebx
	81 e3 ff ff 00 00       # andl   $0xffff,%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# 6d - ADC - Absolute
6d,3:
	8b 1d [X+1]             # movl   XMAPADDR,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 9b [W+1] 00 00    # movsbl ADDR(%ebx),%ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# 6e - ROR - Absolute
#warning - assumes ram target, doesn't check mapper
6e,3:
	83 c5 ff                # addl   $0xffffffff,%ebp
	d0 1d [A+1]             # rcrb   ADDR
	8d 76 06                # leal   6(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	0f be 3d [A+1]          # movsbl ADDR,%edi
	/
# 6f - (bad)
# 70 - BVS
70,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	8b 1d [V]               # movl   VFLAG,%ebx
	81 c3 80 00 00 00       # addl   $0x80,%ebx
	f7 c3 00 ff ff ff       # testl  $-256,%ebx
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 71 - ADC - (Indirect),Y
71,2:
	31 db                   # xorl   %ebx,%ebx
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	66 8b 1d [Z+1]          # movw   ZP,%bx
	01 d3                   # addl   %edx,%ebx

# FIXME - trap I/O
	8d bb 00 e0 ff ff       # leal   0xffffe000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx
	0f be c0                # movsbl %al,%eax
	0f be 1c 3b             # movsbl (%ebx,%edi,1),%ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 05                # leal   0x5(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# 72 - (bad)
# 73 - (bad)
# 74 - (bad)
# 75 - ADC - Zero Page,X
75,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 9b [L]            # movsbl RAM(%ebx),%ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# 76 - ROR - Zero Page,X
76,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	31 db                   # xorl   %ebx,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	8a 9f [L]               # movb   RAM(%edi),%bl
	d0 db                   # rcrb   %bl
	8d 76 06                # leal   0x6(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	88 9f [L]               # movb   %bl,RAM(%edi)
	0f be fb                # movsbl %bl,%edi
	/
# 77 - (bad)
# 78 - SEI
78,1:
	80 0d [F] 04            # orb    $0x04,FLAGS
	83 c6 02                # addl   $2,%esi
	/

# 79 - ADC - Absolute,Y
79,3: # FIXME - cycle count
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	8d ba [W+1] 00 00       # leal   addr(%edx),%edi
	8d 9a [W+1] 00 00       # leal   addr(%edx),%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	83 c5 ff                # addl   $0xffffffff,%ebp
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# 7a - (bad)
# 7b - (bad)
# 7c - (bad)
# 7d - ADC - Absolute,X
7d,3: # FIXME - cycle count
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	8d b9 [W+1] 00 00       # leal   addr(%ecx),%edi
	8d 99 [W+1] 00 00       # leal   addr(%ecx),%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	83 c5 ff                # addl   $0xffffffff,%ebp
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# 7e - ROR - Absolute,X
7e,3:
#warning - assumes ram target, no mapper
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c5 ff                # addl   $0xffffffff,%ebp
	d0 99 [A+1]             # rcrb   ADDR(%ecx)
	8d 76 07                # leal   7(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	0f be b9 [A+1]          # movsbl ADDR(%ecx),%edi
	/
# 7f - (bad)
# 80 - (bad)
# 81 - STA - (Indirect,X)
81,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	83 c6 06                # addl   $0x6,%esi
	0f b7 9b [L]            # movzwl RAM(%ebx),%ebx
	f7 c3 00 80 00 00       # testl  $0x8000,%ebx
	75 23                   # jne    +35
	81 eb 00 20 00 00       # subl   $0x2000,%ebx
	81 fb 00 40 00 00       # cmpl   $0x4000,%ebx
	8d 9b 00 20 00 00       # leal   0x2000(%ebx),%ebx
	72 08                   # jb     +8
	88 83 [L]               # movb   %al,RAM(%ebx)
	eb 0c                   # jmp    +12
	e8 [O]                  # call   OUTPUT
	eb 05                   # jmp    +5
	e8 [Y]                  # call   MAPPER
	/
# 82 - (bad)
# 83 - (bad)
# 84 - STY - Zero Page
84,2:
	83 c6 03                # addl   $0x3,%esi  # cycle count +3
	88 15 [Z+1]             # movb   %dl,ADDR
	/
# 85 - STA - Zero Page
85,2:
	83 c6 03                # addl   $0x3,%esi  # cycle count +3
	a2 [Z+1]                # movb   %al,ADDR
	/
# 86 - STX - Zero Page
86,2:
	83 c6 03                # addl   $0x3,%esi  # cycle count +3
	88 0d [Z+1]             # movb   %cl,ADDR
	/
# 87 - (bad)
# 88 - DEY
88,1:
	4a                      # decl   %edx
	83 c6 02                # addl   $0x2,%esi  # cycle count +2
	0f be fa                # movsbl %dl,%edi
	/
# 89 - (bad)
# 8a - TXA
8a,1:
	88 c8                   # movb   %cl,%al
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
# 8b - (bad)
# 8c - STY - Absolute
8c,3:
	83 c6 04                # addl   $0x4,%esi  # cycle count +4
	88 15 [A+1]             # movb   %dl,ADDR
	/
# 8d - STA - Absolute
8d,3:
	83 c6 04                # addl   $0x4,%esi  # cycle count +4
	a2 [A+1]                # movb   %al,ADDR
	/
# 8e - STX - Absolute
8e,3:
	83 c6 04                # addl   $0x4,%esi  # cycle count +4
	88 0d [A+1]             # movb   %cl,ADDR
	/

# 8f - (bad)
# 90 - BCC
90,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	85 ed                   # testl  %ebp,%ebp
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 84 [U]               # je     U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 91 - STA - (Indirect),Y
91,2:
	31 db                   # xorl   %ebx,%ebx
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	66 8b 1d [Z+1]          # movw   [Z+1],%bx
	66 01 d3                # addw   %dx,%bx
	83 c6 06                # addl   $0x6,%esi
	81 eb 00 20 00 00       # subl   $0x2000,%ebx
	81 fb 00 40 00 00       # cmpl   $0x4000,%ebx
	72 16                   # jb     +22
	81 fb 00 60 00 00       # cmpl   $0x6000,%ebx
	8d 9b 00 20 00 00       # leal   0x2000(%ebx),%ebx
	7d 15                   # jnl    +21
	88 83 [L]               # movb   %al,RAM(%ebx)
	eb 12                   # jmp    +18
	81 c3 00 20 00 00       # addl   $0x2000,%ebx
	e8 [O]                  # call   OUTPUT
	eb 05                   # jmp    +5
	e8 [Y]                  # call   MAPPER
	/
# 92 - (bad)
# 93 - (bad)
# 94 - STY - Zero Page,X
94,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	88 93 [L]               # movb   %dl,RAM(%ebx)
	/
# 95 - STA - Zero Page,X
95,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	88 83 [L]               # movb   %al,RAM(%ebx)
	/
# 96 - STX - Zero Page,Y
96,2:
	8d 5a [B+1]             # leal   [B+1](%edx),%ebx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	88 8b [L]               # movb   %cl,RAM(%ebx)
	/
# 97 - (bad)
# 98 - TYA
98,1:
	88 d0                   # movb   %dl,%al
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
# 99 - STA - Absolute,Y
99,3:
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	83 c6 05                # addl   $5,%esi    # cycle count +5
	88 82 [A+1]             # movb   %al,[A+1](%edx)
	/
# 9a - TXS
9a,1:
	88 0d [S]               # movb   %cl,STACKPTR
	83 c6 02                # addl   $2,%esi
	/
# 9b - (bad)
# 9c - (bad)
# 9d - STA - Absolute,X
9d,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c6 05                # addl   $5,%esi    # cycle count +5
	88 81 [A+1]             # movb   %al,[A+1](%ecx)
	/
# 9e - (bad)
# 9f - (bad)
# a0 - LDY - Immediate
a0,2:
	31 d2                   # xorl   %edx,%edx
	83 c6 02                # addl   $0x2,%esi
	b2 [B+1]                # movb   $[B+1],%dl
	bf [E+1]                # movl   $[E+1],%edi
	/
# a1 - LDA - (Indirect,X)
#   # has wraparound bug (ff->100) but it probably doesn't matter
a1,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	31 db                   # xorl   %ebx,%ebx
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	66 8b 9f [L]            # movw   RAM(%edi),%bx
	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	8d 76 06                # leal   0x6(%esi),%esi
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx

# FIXME - trap I/O
	81 fb 00 60 00 00       # cmpl   $0x6000,%ebx
	73 09                   # jae    +9
	81 fb 00 20 00 00       # cmpl   $0x2000,%ebx
	72 01                   # jb     +1
	[^]                     # int3

	0f be 04 1f             # movsbl (%edi,%ebx,1),%eax
	89 c7                   # movl   %eax,%edi
	/
# a2 - LDX - Immediate
a2,2:
	31 c9                   # xorl   %ecx,%ecx
	83 c6 02                # addl   $0x2,%esi  # cycle count +2
	b1 [B+1]                # movb   $[B+1],%cl
	bf [E+1]                # movl   $[E+1],%edi
	/
# a3 - (bad)
# a4 - LDY - Zero Page
a4,2:
	31 d2                   # xorl   %edx,%edx
	83 c6 03                # addl   $0x3,%esi  # cycle count +3
	8a 15 [Z+1]             # movb   ZPADDR,%dl
	0f be fa                # movsbl %dl,%edi
	/
# a5 - LDA - Zero Page
a5,2:
	0f be 05 [Z+1]          # movsbl ZPADDR,%eax
	83 c6 03                # addl   $0x3,%esi  # cycle count +3
	89 c7                   # movl   %eax,%edi
	/
# a6 - LDX - Zero Page
a6,2:
	31 c9                   # xorl   %ecx,%ecx
	bf 80 ff ff ff          # movl   $0xffffff80,%edi
	8a 0d [Z+1]             # movb   ZP,%cl
	83 c6 03                # addl   $0x3,%esi  # cycle count +3
	01 cf                   # addl   %ecx,%edi
	83 f7 80                # xorl   $0xffffff80,%edi
	/
# a7 - (bad)
# a8 - TAY
a8,1:
	88 c2                   # movb   %al,%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 02                # addl   $2,%esi
	/
# a9 - LDA - Immediate
a9,2:
	b8 [E+1]                # movl   $[E+1],%eax
	83 c6 02                # addl   $0x2,%esi  # cycle count +2
	bf [E+1]                # movl   $[E+1],%edi
	/
# aa - TAX
aa,1:
	88 c1                   # movb   %al,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 02                # addl   $2,%esi
	/
# ab - (bad)
# ac - LDY - Absolute
ac,3:
	8b 1d [X+1]             # movl   XMAP,%ebx
	83 c6 04                # addl   $0x4,%esi
	0f be 93 [W+1] 00 00    # movsbl RAM(%ebx),%edx
	89 d7                   # movl   %edx,%edi
	/
# ad - LDA - Absolute
ad,3:
	8b 1d [X+1]             # movl   XMAP,%ebx
	83 c6 04                # addl   $0x4,%esi
	0f be 83 [W+1] 00 00    # movsbl 0x0000AAAA(%ebx),%eax
	89 c7                   # movl   %eax,%edi
	/
# ae - LDX - Absolute
ae,3:
	8b 1d [X+1]             # movl   XMAP,%ebx
	83 c6 04                # addl   $0x4,%esi
	0f be 8b [W+1] 00 00    # movsbl 0x0000AAAA(%ebx),%ecx
	89 cf                   # movl   %ecx,%edi
	/
# af - (bad)
# b0 - BCS
b0,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	85 ed                   # testl  %ebp,%ebp
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# b1 - LDA - (Indirect),Y
b1,2:
	31 db                   # xorl   %ebx,%ebx
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	66 8b 1d [Z+1]          # movw   ZP,%bx
	01 d3                   # addl   %edx,%ebx
	8d 76 05                # leal   0x5(%esi),%esi
	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $0xc,%edi
	8d 83 00 e0 ff ff       # leal   0xffffe000(%ebx),%eax
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	3d 00 40 00 00          # cmpl   $0x4000,%eax
	73 07                   # jae    +7
	e8 [I]                  # call   INPUT
	eb 04                   # jmp    +4
	0f be 3c 1f             # movsbl (%edi,%ebx,1),%edi
	89 f8                   # movl   %edi,%eax
	/
# b2 - (bad)
# b3 - (bad)
# b4 - LDY - Zero Page,X
b4,2:
	8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
	31 d2                   # xorl   %edx,%edx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	8a 93 [L]               # movb   RAM(%ebx),%dl
	0f be fa                # movsbl %dl,%edi
	/
# b5 - LDA - Zero Page,X
b5,2:
	8d 41 [B+1]             # leal   [B+1](%ecx),%eax
	25 ff 00 00 00          # andl   $0xff,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	0f be 80 [L]            # movsbl RAM(%eax),%eax
	89 c7                   # movl   %eax,%edi
	/
# b6 - LDX - Zero Page,Y
b6,2:
	8d 5a [B+1]             # leal   [B+1](%edx),%ebx
	31 c9                   # xorl   %ecx,%ecx
	81 e3 ff 00 00 00       # andl   $0xff,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	8a 8b [L]               # movb   RAM(%ebx),%cl
	0f be f9                # movsbl %cl,%edi
	/
# b7 - (bad)
# b8 - CLV
b8,1:
	c7 05 [V] 00 00 00 00   # movl   $0,VFLAG
	83 c6 02                # addl   $2,%esi
	/
# b9 - LDA - Absolute,Y
b9,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	8d 82 [W+1] 00 00       # leal   ADDR(%edx),%eax
	c1 e8 0c                # shrl   $0xc,%eax
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	8b 3c 85 [M]            # movl   MAPTABLE(,%eax,4),%edi
	83 c6 04                # addl   $0x4,%esi
	0f be 04 1f             # movsbl (%edi,%ebx,1),%eax
	89 c7                   # movl   %eax,%edi
	/
# ba - TSX
ba,1:
	8a 0d [S]               # movb   STACKPTR,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 02                # addl   $2,%esi
	/
# bb - (bad)
# bc - LDY - Absolute,X
bc,3:
# FIXME - cycle count wrong
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	8d 91 [W+1] 00 00       # leal   ADDR(%ecx),%edx
	c1 ea 0c                # shrl   $0xc,%edx
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	8b 3c 95 [M]            # movl   MAPTABLE(,%edx,4),%edi
	83 c6 04                # addl   $0x4,%esi
	0f be 14 1f             # movsbl (%edi,%ebx,1),%edx
	89 d7                   # movl   %edx,%edi
	/
# bd - LDA - Absolute,X
bd,3:
# FIXME - cycle count wrong
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	8d 81 [W+1] 00 00       # leal   ADDR(%ecx),%eax
	c1 e8 0c                # shrl   $0xc,%eax
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	8b 3c 85 [M]            # movl   MAPTABLE(,%eax,4),%edi
	83 c6 04                # addl   $0x4,%esi
	0f be 04 1f             # movsbl (%edi,%ebx,1),%eax
	89 c7                   # movl   %eax,%edi
	/
# be - LDX - Absolute,Y
be,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	8d 8a [W+1] 00 00       # leal   ADDR(%edx),%ecx
	c1 e9 0c                # shrl   $0xc,%ecx
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	8b 3c 8d [M]            # movl   MAPTABLE(,%ecx,4),%edi
	83 c6 04                # addl   $0x4,%esi
	0f be 0c 1f             # movsbl (%edi,%ebx,1),%ecx
	89 cf                   # movl   %ecx,%edi
	/
# bf - (bad)
# c0 - CPY - Immediate
c0,2:
	0f b6 da                # movzbl %dl,%ebx
	bd 01 00 00 00          # movl   $0x1,%ebp
	81 eb [B+1] 00 00 00    # subl   $[B+1],%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	8d 76 02                # leal   0x2(%esi),%esi  # cycle count +2
	/
# c1 - CMP - (Indirect,X)
c1,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	31 db                   # xorl   %ebx,%ebx
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	25 ff 00 00 00          # andl   $0xff,%eax
	66 8b 9f [L]            # movw   RAM(%edi),%bx

# FIXME - trap I/O
	8d bb 00 e0 ff ff       # leal   0xffffe000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	8d 76 06                # leal   0x6(%esi),%esi
	8b 2c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebp
	89 c3                   # movl   %eax,%ebx
	0f b6 3c 2f             # movzbl (%edi,%ebp,1),%edi
	bd 01 00 00 00          # movl   $0x1,%ebp
	29 fb                   # subl   %edi,%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# c2 - (bad)
# c3 - (bad)
# c4 - CPY - Zero Page
c4,2:
	0f b6 da                # movzbl %dl,%ebx
	0f b6 3d [Z+1]          # movzbl ZP,%edi
	bd 01 00 00 00          # movl   $0x1,%ebp
	29 fb                   # subl   %edi,%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	8d 76 03                # leal   0x3(%esi),%esi  # cycle count +3
	/
# c5 - CMP - Zero Page
c5,2:
	31 db                   # xorl   %ebx,%ebx
	0f b6 3d [Z+1]          # movzbl ZP,%edi
	88 c3                   # movb   %al,%bl
	bd 01 00 00 00          # movl   $0x1,%ebp
	29 fb                   # subl   %edi,%ebx
	8d 76 03                # leal   0x3(%esi),%esi  # cycle count +3
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# c6 - DEC - Zero Page
c6,2:
	31 db                   # xorl   %ebx,%ebx
	8a 1d [Z+1]             # movb   ZP,%bl
	80 eb 81                # subb   $0x81,%bl
	83 c6 05                # addl   $0x5,%esi  # cycle count +5
	81 eb 80 00 00 00       # subl   $0x80,%ebx
	89 df                   # movl   %ebx,%edi
	88 1d [Z+1]             # movb   %bl,ZP
	/
# c7 - (bad)
# c8 - INY
c8,1:
	42                      # incl   %edx
	83 c6 02                # addl   $0x2,%esi  # cycle count +2
	0f be fa                # movsbl %dl,%edi
	/
# c9 - CMP - Immediate
c9,2:
	bd 01 00 00 00          # movl   $1,%ebp
	0f b6 d8                # movzbl %al,%ebx
	83 c6 02                # addl   $2,%esi  # cycle count +2
	81 eb [B+1] 00 00 00    # subl   $[B+1],%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0,%ebp
	/
# ca - DEX
ca,1:
	49                      # decl   %ecx
	83 c6 02                # addl   $0x2,%esi  # cycle count +2
	0f be f9                # movsbl %cl,%edi
	/
# cb - (bad)
# cc - CPY - Absolute
cc,3:
	8b 3d [X+1]             # movl   X,%edi
	31 db                   # xorl   %ebx,%ebx
	bd 01 00 00 00          # movl   $0x1,%ebp
	88 d3                   # movb   %dl,%bl
	0f b6 bf [W+1] 00 00    # movzbl ADDR(%edi),%edi
	29 fb                   # subl   %edi,%ebx
	8d 76 04                # leal   4(%esi),%esi
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# cd - CMP - Absolute
cd,3:
	8b 3d [X+1]             # movl   X,%edi
	31 db                   # xorl   %ebx,%ebx
	bd 01 00 00 00          # movl   $0x1,%ebp
	88 c3                   # movb   %al,%bl
	0f b6 bf [W+1] 00 00    # movzbl ADDR(%edi),%edi
	29 fb                   # subl   %edi,%ebx
	8d 76 04                # leal   4(%esi),%esi
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# ce - DEC - Absolute
ce,3:
	31 db                   # xorl   %ebx,%ebx
	8a 1d [A+1]             # movb   ADDR,%bl
	80 eb 81                # subb   $0x81,%bl
	83 c6 06                # addl   $0x6,%esi  # cycle count +6
	81 eb 80 00 00 00       # subl   $0x80,%ebx
	89 df                   # movl   %ebx,%edi
	88 1d [A+1]             # movb   %bl,ADDR
	/
# cf - (bad)
# d0 - BNE
d0,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# d1 - CMP   (Indirect),Y
d1,2:
	31 db                   # xorl   %ebx,%ebx
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	66 8b 1d [Z+1]          # movw   [Z+1],%bx
	25 ff 00 00 00          # andl   $0xff,%eax
	01 d3                   # addl   %edx,%ebx

# FIXME - trap I/O
	8d bb 00 e0 ff ff       # leal   0xffffe000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	8d 76 05                # leal   0x5(%esi),%esi
	8b 2c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebp
	89 c3                   # movl   %eax,%ebx
	0f b6 3c 2f             # movzbl (%edi,%ebp,1),%edi
	bd 01 00 00 00          # movl   $0x1,%ebp
	29 fb                   # subl   %edi,%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# d2 - (bad)
# d3 - (bad)
# d4 - (bad)
# d5 - CMP - Zero Page,X
d5,2:
	8d 69 [B+1]             # leal   [B+1](%ecx),%ebp
	31 db                   # xorl   %ebx,%ebx
	81 e5 ff 00 00 00       # andl   $0xff,%ebp
	88 c3                   # movb   %al,%bl
	8d 76 04                # leal   0x4(%esi),%esi
	0f b6 bd [L]            # movzbl RAM(%ebp),%edi
	29 fb                   # subl   %edi,%ebx
	bd 01 00 00 00          # movl   $0x1,%ebp
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# d6 - DEC - Zero Page,X
d6,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	31 db                   # xorl   %ebx,%ebx
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	8a 9f [L]               # movb   RAM(%edi),%bl
	80 eb 81                # subb   $0x81,%bl
	83 c6 06                # addl   $0x6,%esi
	81 eb 80 00 00 00       # subl   $0x80,%ebx
	88 9f [L]               # movb   %bl,RAM(%edi)
	89 df                   # movl   %ebx,%edi
	/
# d7 - (bad)
# d8 - CLD
d8,1:
	80 25 [F] f7            # andb   $0xf7,FLAGS
	83 c6 02                # addl   $2,%esi
	/
# d9 - CMP - Absolute,Y
d9,3:
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	25 ff 00 00 00          # andl   $0xff,%eax
	8d 9a [W+1] 00 00       # leal   [W+1](%edx),%ebx
	89 df                   # movl   %ebx,%edi
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $0x4,%esi
	c1 eb 0c                # shrl   $0xc,%ebx
	8b 2c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebp
	89 c3                   # movl   %eax,%ebx
	0f b6 3c 2f             # movzbl (%edi,%ebp,1),%edi
	bd 01 00 00 00          # movl   $0x1,%ebp
	29 fb                   # subl   %edi,%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# da - (bad)
# db - (bad)
# dc - (bad)
# dd - CMP - Absolute,X
dd,3:
# FIXME - cycle count wrong
	bd [W+1] 00 00          # movl   $ADDR,%ebp
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	01 cd                   # addl   %ecx,%ebp
	31 db                   # xorl   %ebx,%ebx
	c1 ed 0c                # shrl   $0xc,%ebp
	88 c3                   # movb   %al,%bl
	8b 2c ad [M]            # movl   MAPTABLE(,%ebp,4),%ebp
	8d 76 04                # leal   0x4(%esi),%esi
	0f b6 bc 29 [W+1] 00 00 # movzbl ADDR(%ecx,%ebp,1),%edi
	bd 01 00 00 00          # movl   $0x1,%ebp
	29 fb                   # subl   %edi,%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# de - DEC - Absolute,X
de,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	31 db                   # xorl   %ebx,%ebx
	8a 99 [A+1]             # movb   ADDR(%ecx),%bl
	80 eb 81                # subb   $0x81,%bl
	83 c6 07                # addl   $0x7,%esi  # cycle count +7
	81 eb 80 00 00 00       # subl   $0x80,%ebx
	89 df                   # movl   %ebx,%edi
	88 99 [A+1]             # movb   %bl,ADDR(%ecx)
	/
# df - (bad)
# e0 - CPX - Immediate
e0,2:
	0f b6 d9                # movzbl %cl,%ebx
	bd 01 00 00 00          # movl   $0x1,%ebp
	81 eb [B+1] 00 00 00    # subl   $[B+1],%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	8d 76 02                # leal   0x2(%esi),%esi  # cycle count +2
	/
# e1 - SBC - (Indirect,X)
# e2 - (bad)
# e3 - (bad)
# e4 - CPX - Zero Page
e4,2:
	0f b6 d9                # movzbl %cl,%ebx
	0f b6 3d [Z+1]          # movzbl [Z+1],%edi
	bd 01 00 00 00          # movl   $0x1,%ebp
	29 fb                   # subl   %edi,%ebx
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	8d 76 03                # leal   0x3(%esi),%esi  # cycle count +3
	/
# e5 - SBC - Zero Page
e5,2:
	0f be 1d [Z+1]          # movsbl [Z+1],%ebx
	0f be c0                # movsbl %al,%eax
	83 f3 ff                # xorl   $0xffffffff,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	11 d8                   # adcl   %ebx,%eax
	8d 76 03                # leal   0x3(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# e6 - INC - Zero Page
e6,2:
	31 db                   # xorl   %ebx,%ebx
	8a 1d [Z+1]             # movb   ZP,%bl
	80 c3 81                # addb   $0x81,%bl
	83 c6 05                # addl   $0x5,%esi  # cycle count +5
	81 eb 80 00 00 00       # subl   $0x80,%ebx
	89 df                   # movl   %ebx,%edi
	88 1d [Z+1]             # movb   %bl,ZP
	/
# e7 - (bad)
# e8 - INX
e8,1:
	41                      # incl   %ecx
	83 c6 02                # addl   $0x2,%esi  # cycle count +2
	0f be f9                # movsbl %cl,%edi
	/
# e9 - SBC - Immediate
e9,2:
	83 c5 ff                # addl   $0xffffffff,%ebp
	0f be c0                # movsbl %al,%eax
	83 d0 [C+1]             # adcl   $[C+1],%eax
	8d 76 02                # leal   0x2(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
#alternatively, could do: subl $0x1,%ebp
#                         sbbl $imm,%eax
# but then the carry flag must be inverted again before putting into ebp,
# so it's easier to invert the immediate value
	/
# ea - NOP
ea,1:
	83 c6 02                # addl   $0x2,%esi  # cycle count +2
	/
# eb - (bad)
# ec - CPX - Absolute
ec,3:
	8b 3d [X+1]             # movl   XLATADDR,%edi
	31 db                   # xorl   %ebx,%ebx
	bd 01 00 00 00          # movl   $0x1,%ebp
	88 cb                   # movb   %cl,%bl
	0f b6 bf [W+1] 00 00    # movzbl ADDR(%edi),%edi
	29 fb                   # subl   %edi,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	0f be fb                # movsbl %bl,%edi
	83 dd 00                # sbbl   $0x0,%ebp
	/
# ed - SBC - Absolute
ed,3:
	8b 3d [X+1]             # movl   XMAPADDR,%edi
	25 ff 00 00 00          # andl   $0xff,%eax
	31 db                   # xorl   %ebx,%ebx
	83 c0 80                # addl   $0xffffff80,%eax
	8a 9f [W+1] 00 00       # movb   ADDR(%edi),%bl
	83 f0 80                # xorl   $0xffffff80,%eax
	83 c3 80                # addl   $0xffffff80,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	83 f3 7f                # xorl   $0x7f,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	11 d8                   # adcl   %ebx,%eax
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# ee - INC - Absolute
ee,3:
	31 db                   # xorl   %ebx,%ebx
	8a 1d [A+1]             # movb   ADDR,%bl
	80 c3 81                # addb   $0x81,%bl
	83 c6 06                # addl   $0x6,%esi  # cycle count +6
	81 eb 80 00 00 00       # subl   $0x80,%ebx
	89 df                   # movl   %ebx,%edi
	88 1d [A+1]             # movb   %bl,ADDR
	/
# ef - (bad)
# f0 - BEQ
f0,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 84 [U]               # je     U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# f1 - SBC - (Indirect),Y
f1,2:
	31 db                   # xorl   %ebx,%ebx
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	66 8b 1d [Z+1]          # movw   ZP,%bx
	01 d3                   # addl   %edx,%ebx

# FIXME - trap I/O
	8d bb 00 e0 ff ff       # leal   0xffffe000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $0xc,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	8b 1c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebx
	0f be c0                # movsbl %al,%eax
	0f be 1c 3b             # movsbl (%ebx,%edi,1),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 05                # leal   0x5(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# f2 - (bad)
# f3 - (bad)
# f4 - (bad)
# f5 - SBC - Zero Page,X
f5,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	25 ff 00 00 00          # andl   $0xff,%eax
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	31 db                   # xorl   %ebx,%ebx
	83 c0 80                # addl   $0xffffff80,%eax
	8a 9f [L]               # movb   RAM(%edi),%bl
	83 f0 80                # xorl   $0xffffff80,%eax
	83 c3 80                # addl   $0xffffff80,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	83 f3 7f                # xorl   $0x7f,%ebx
	83 c5 ff                # addl   $0xffffffff,%ebp
	11 d8                   # adcl   %ebx,%eax
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# f6 - INC - Zero Page,X
f6,2:
	8d 79 [B+1]             # leal   [B+1](%ecx),%edi
	81 e7 ff 00 00 00       # andl   $0xff,%edi
	31 db                   # xorl   %ebx,%ebx
	8a 9f [L]               # movb   RAM(%edi),%bl
	80 c3 81                # addb   $0x81,%bl
	83 c6 06                # addl   $0x6,%esi
	81 eb 80 00 00 00       # subl   $0x80,%ebx
	88 9f [L]               # movb   %bl,RAM(%edi)
	89 df                   # movl   %ebx,%edi
	/
# f7 - (bad)
# f8 - SED
f8,1: #What happens on a real NES when the CPU is put into decimal mode?
	80 0d [F] 08            # orb    $0x08,FLAGS
	83 c6 02                # addl   $2,%esi
	/
# f9 - SBC - Absolute,Y
f9,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	25 ff 00 00 00          # andl   $0xff,%eax
	8d ba [W+1] 00 00       # leal   ADDR(%edx),%edi
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	83 c0 80                # addl   $0xffffff80,%eax
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 f0 80                # xorl   $0xffffff80,%eax
	83 c5 ff                # addl   $0xffffffff,%ebp
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# fa - (bad)
# fb - (bad)
# fc - (bad)
# fd - SBC - Absolute,X
fd,3:
# FIXME - cycle count wrong
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	25 ff 00 00 00          # andl   $0xff,%eax
	8d b9 [W+1] 00 00       # leal   ADDR(%ecx),%edi
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	83 c0 80                # addl   $0xffffff80,%eax
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 f0 80                # xorl   $0xffffff80,%eax
	83 c5 ff                # addl   $0xffffffff,%ebp
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/
# fe - INC - Absolute,X
fe,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	31 db                   # xorl   %ebx,%ebx
	8a 99 [A+1]             # movb   [A+1](%ecx),%bl
	80 c3 81                # addb   $0x81,%bl
	83 c6 07                # addl   $0x7,%esi
	81 eb 80 00 00 00       # subl   $0x80,%ebx
	89 df                   # movl   %ebx,%edi
	88 99 [A+1]             # movb   %bl,[A+1](%ecx)
	/
# ff - (bad)

#-----------------------------------------------------------------------------
# Specific Optimizations

# movsx is slow (3 cycles on a Pentium) so we eliminate it whenever possible:

09 80/80,2: # ORA with a negative is always negative (and nonzero)
	0d [E+1]                # orl    $[E+1],%eax
	83 c6 02                # addl   $2,%esi
	bf ff ff ff ff          # movl   $0xffffffff,%edi
	/
09/bf 00/ff,2: # ORA/EOR #$00  (set flags only)
	83 c6 02                # addl   $2,%esi
	0f be f8                # movsbl %al,%edi
	/
09 ff/ff,2: # ORA #$ff  (set all bits)
	b8 ff ff ff ff          # movl   $0xffffffff,%eax
	83 c6 02                # addl   $2,%esi
	bf ff ff ff ff          # movl   $0xffffffff,%edi
	/
29 00/80,2: # AND with a positive value is always positive (sign flag=0)
	25 [E+1]                # andl   $[E+1],%eax
	83 c6 02                # addl   $2,%esi
	89 c7                   # movl   %eax,%edi
	/
29 00/ff,2: # AND #$00  (clear registers only)
	31 c0                   # xorl   %eax,%eax
	83 c6 02                # addl   $2,%esi
	31 ff                   # xorl   %edi,%edi
	/
29 ff/ff,2: # AND #$ff  (set flags only)
	83 c6 02                # addl   $2,%esi
	0f be f8                # movsbl %al,%edi
	/
a9 00,2: # LDA #$00  (clear registers only, same as AND #0)
	83 c6 02                # addl   $2,%esi
	31 c0                   # xorl   %eax,%eax
	31 ff                   # xorl   %edi,%edi
	/
a2 00,2: # LDX #$00  (clear registers)
	83 c6 02                # addl   $2,%esi
	31 c9                   # xorl   %ecx,%ecx
	31 ff                   # xorl   %edi,%edi
	/
a0 00,2: # LDY #$00  (clear registers)
	83 c6 02                # addl   $2,%esi
	31 d2                   # xorl   %edx,%edx
	31 ff                   # xorl   %edi,%edi
	/

# CLC followed by ADC -> ADD
18 69,3:
	0f be c0                # movsbl %al,%eax
	83 c0 [B+2]             # addl   $[B+2],%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# SEC followed by SBC -> SUB
31 e9,3:
	0f be c0                # movsbl %al,%eax
	83 e8 [B+2]             # subl   $[B+2],%eax
	f5                      # cmc
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/

# Repeated NOP
ea ea,2:
	83 c6 04                # addl   $0x4,%esi  # cycle count +4
	/
ea ea ea,3:
	83 c6 06                # addl   $0x6,%esi  # cycle count +6
	/
ea ea ea ea,4:
	83 c6 08                # addl   $0x8,%esi  # cycle count +8
	/

# Repeated INX
e8 e8,2:
	83 c1 02                # addl   $0x2,%ecx
	83 c6 04                # addl   $4,%esi  # cycle count +2x2
	0f be f9                # movsbl %cl,%edi
	/
e8 e8 e8,3:
	83 c1 03                # addl   $0x3,%ecx
	83 c6 06                # addl   $6,%esi  # cycle count +2x3
	0f be f9                # movsbl %cl,%edi
	/
e8 e8 e8 e8,4:
	83 c1 04                # addl   $0x4,%ecx
	83 c6 08                # addl   $8,%esi  # cycle count +2x4
	0f be f9                # movsbl %cl,%edi
	/

# Repeated INY
c8 c8,2:
	83 c2 02                # addl   $0x2,%edx
	83 c6 04                # addl   $4,%esi  # cycle count +2x2
	0f be fa                # movsbl %dl,%edi
	/
c8 c8 c8,3:
	83 c2 03                # addl   $0x3,%edx
	83 c6 06                # addl   $6,%esi  # cycle count +3x2
	0f be fa                # movsbl %dl,%edi
	/
c8 c8 c8 c8,4:
	83 c2 04                # addl   $0x4,%edx
	83 c6 08                # addl   $8,%esi  # cycle count +4x2
	0f be fa                # movsbl %dl,%edi
	/

# Repeated DEX
ca ca,2:
	83 e9 02                # subl   $0x2,%ecx
	83 c6 04                # addl   $4,%esi  # cycle count +4
	0f be f9                # movsbl %cl,%edi
	/
ca ca ca,3:
	83 e9 03                # subl   $0x3,%ecx
	83 c6 06                # addl   $6,%esi  # cycle count +6
	0f be f9                # movsbl %cl,%edi
	/
ca ca ca ca,4:
	83 e9 04                # subl   $0x4,%ecx
	83 c6 08                # addl   $8,%esi  # cycle count +8
	0f be f9                # movsbl %cl,%edi
	/

# Repeated DEY
88 88,2:
	83 ea 02                # subl   $0x2,%edx
	83 c6 04                # addl   $4,%esi  # cycle count +4
	0f be fa                # movsbl %dl,%edi
	/
88 88 88,3:
	83 ea 03                # subl   $0x3,%edx
	83 c6 06                # addl   $6,%esi  # cycle count +6
	0f be fa                # movsbl %dl,%edi
	/
88 88 88 88,4:
	83 ea 04                # subl   $0x4,%edx
	83 c6 08                # addl   $8,%esi  # cycle count +8
	0f be fa                # movsbl %dl,%edi
	/

# Repeated ASL
0a 0a,2:
	c0 e0 02                # shlb   $0x2,%al
	8d 76 04                # leal   0x4(%esi),%esi  # cycle count +4
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	/
0a 0a 0a,3:
	c0 e0 03                # shlb   $0x3,%al
	8d 76 06                # leal   0x6(%esi),%esi  # cycle count +6
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	/
0a 0a 0a 0a,4:
	c0 e0 04                # shlb   $0x4,%al
	8d 76 08                # leal   0x8(%esi),%esi  # cycle count +8
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	/

# Repeated LSR
4a 4a,2:
	25 ff 00 00 00          # andl   $0xff,%eax
	c1 e8 02                # shrl   $0x2,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	89 c7                   # movl   %eax,%edi
	/
4a 4a 4a,3:
	25 ff 00 00 00          # andl   $0xff,%eax
	c1 e8 03                # shrl   $0x3,%eax
	8d 76 06                # leal   0x6(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	89 c7                   # movl   %eax,%edi
	/
4a 4a 4a 4a,4:
	25 ff 00 00 00          # andl   $0xff,%eax
	c1 e8 04                # shrl   $0x4,%eax
	8d 76 08                # leal   0x8(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	89 c7                   # movl   %eax,%edi
	/


# Predictable branches.  Sometimes a 'conditional' branch is in fact always
# taken.  It is good to recognize these cases, because the branch may be
# followed by non-executable data, which we don't want to try to translate.

# LDA of non-zero followed by BNE is always taken
a9 00/00 d0,4:
	b8 [E+1]                # movl   $[E+1],%eax
	83 c6 [>+3] 05          # addl   $5+,%esi # do timing count
	bf [E+1]                # movl   $[E+1],%edi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDA #0 followed by BNE is never taken (overrides previous case for LDA #0)
a9 00 d0,4:
	31 c0                   # xorl   %eax,%eax
	31 ff                   # xorl   %edi,%edi
	8d 76 04                # leal   4(%esi),%esi # do timing count
	/
# LDX of non-zero followed by BNE is always taken
a2 00/00 d0,4:
	b9 [E+1]                # movl   $[E+1],%ecx
	bf [E+1]                # movl   $[E+1],%edi
	83 c6 [>+3] 05          # addl   $5+,%esi # do timing count
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDX #0 followed by BNE is never taken (overrides previous case for LDX #0)
a2 00 d0,4:
	31 c9                   # xorl   %ecx,%ecx
	31 ff                   # xorl   %edi,%edi
	8d 76 04                # leal   4(%esi),%esi # do timing count
	/

# LDY of non-zero followed by BNE is always taken
a0 00/00 d0,4:
	ba [E+1]                # movl   $[E+1],%edx
	bf [E+1]                # movl   $[E+1],%edi
	83 c6 [>+3] 05          # addl   $5+,%esi # do timing count
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDY #0 followed by BNE is never taken (overrides previous case for LDY #0)
a0 00 d0,4:
	31 d2                   # xorl   %edx,%edx
	31 ff                   # xorl   %edi,%edi
	8d 76 04                # leal   4(%esi),%esi # do timing count
	/

# LDA #0 followed by BEQ is always taken
a9 00 f0,4:
	31 c0                   # xorl   %eax,%eax
	31 ff                   # xorl   %edi,%edi
	8d 76 [>+3] 05          # leal   5+(%esi),%esi # do timing count
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDX #0 followed by BEQ is always taken
a2 00 f0,4:
	31 c9                   # xorl   %ecx,%ecx
	31 ff                   # xorl   %edi,%edi
	8d 76 [>+3] 05          # leal   5+(%esi),%esi # do timing count
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDY #0 followed by BEQ is always taken
a0 00 f0,4:
	31 d2                   # xorl   %edx,%edx
	31 ff                   # xorl   %edi,%edi
	8d 76 [>+3] 05          # leal   5+(%esi),%esi # do timing count
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/

# This shows up quite a bit also... LDA #0 / STA / BEQ
a9 00 85 00/00 f0,6:
	31 c0                   # xorl   %eax,%eax
	31 ff                   # xorl   %edi,%edi
	8d 76 [>+5] 08          # leal   8+(%esi),%esi # do timing count
	a2 [Z+3]                # movb   %al,[Z+3]
	bb [R+5]                # movl   $[R+5],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/

# Also a9..95..d0  LDA #xx / STA 00,X / BNE
#a9 00/00 95 00/00 d0,6:
#	b8 [E+1]                # movl   $[E+1],%eax
#	8d 59 [B+3]             # leal   [B+3](%ecx),%ebx
#	bf [E+1]                # movl   $[E+1],%edi
#	81 e3 ff 00 00 00       # andl   $0xff,%ebx
#	8d 76 09                # leal   0x9(%esi),%esi
#	88 83 [L]               # movb   %al,RAM(%ebx)
#	bb [R+5]                # movl   $[R+5],%ebx
#	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
#	e9 [U]                  # jmp    U
#	[!]
#	/
#a9 00 95 00/00 d0,6:   # For LDA #00 case...
#	31 c0                   # xorl   %eax,%eax
#	8d 59 [B+3]             # leal   [B+3](%ecx),%ebx
#	31 ff                   # xorl   %edi,%edi
#	81 e3 ff 00 00 00       # andl   $0xff,%ebx
#	8d 76 08                # leal   0x8(%esi),%esi
#	88 83 [L]               # movb   %al,RAM(%ebx)
#	/

# ORA of non-zero followed by BNE is always taken
09 00/00 d0,4:
	83 c8 [B+1]             # orl    $[B+1],%eax
	83 c6 [>+3] 05          # addl   $5+,%esi # do timing count
	0f be f8                # movsbl %al,%edi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
09 00 d0,4: # ORA #$00 / BNE
	0f be f8                # movsbl %al,%edi
	83 c6 [>+3] 05          # addl   $5+,%esi # timing
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+3] 01          # subl   $1+,%esi
	/

# Branch pairs (one or the other is always taken)

# BNE/BEQ
#d0 00/00 f0,4:
#	83 c6 03                # addl   $3,%esi
#	bb [P]                  # movl   $[P],%ebx
#	0f 89 [N]               # jns    NMI
#	f7 c7 ff 00 00 00       # testl  $0xff,%edi
#	bb [R+1]                # movl   $[R+1],%ebx
#	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
#	0f 85 [U]               # jne    U
#	83 c6 02                # addl   $2,%esi
#	bb [R+3]                # movl   $[R+3],%ebx
#	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
#	e9 [U]                  # jmp    U
#	[!]                     # STOP
#	/
# BEQ/BNE
#f0 00/00 d0,4:
#	83 c6 03                # addl   $3,%esi
#	bb [P]                  # movl   $[P],%ebx
#	0f 89 [N]               # jns    NMI
#	f7 c7 ff 00 00 00       # testl  $0xff,%edi
#	bb [R+1]                # movl   $[R+1],%ebx
#	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
#	0f 84 [U]               # je     U
#	83 c6 02                # addl   $2,%esi
#	bb [R+3]                # movl   $[R+3],%ebx
#	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
#	e9 [U]                  # jmp    U
#	[!]                     # STOP
#	/

#-----------------------------------------------------------------------------
# Writes to Mapper Registers

# STA $8000+  - write mapper regs
8d 00/00 80/80,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# STX $8000+  - write mapper regs
8e 00/00 80/80,3:
	91                      # xchgl  %eax,%ecx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [Y]                  # call   MAPPER
	91                      # xchgl  %eax,%ecx
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# STY $8000+  - write mapper regs
8c 00/00 80/80,3:
	92                      # xchgl  %eax,%edx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [Y]                  # call   MAPPER
	92                      # xchgl  %eax,%edx
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# STA $8xxx,X  - write to mapper
9d 00/00 80/80,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c6 05                # addl   $0x5,%esi
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/
# STA $8xxx,Y  - write to mapper
99 00/00 80/80,3:
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	83 c6 05                # addl   $0x5,%esi
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# STA $7fxx,X or $ffxx,X - possibly write to mapper
9d 00/00 7f/7f,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c6 05                # addl   $0x5,%esi
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	f7 c3 00 80 00 00       # testl  $0x8000,%ebx
	74 17                   # je     +23
	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	81 e3 ff ff 00 00       # andl   $0xffff,%ebx
	88 83 [L]               # movb   %al,RAM(%ebx)
	/

# STA $7fxx,Y or $ffxx,Y - possibly write to mapper
99 00/00 7f/7f,3:
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	83 c6 05                # addl   $0x5,%esi
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	f7 c3 00 80 00 00       # testl  $0x8000,%ebx
	74 17                   # je     +23
	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	81 e3 ff ff 00 00       # andl   $0xffff,%ebx
	88 83 [L]               # movb   %al,RAM(%ebx)
	/

# INC $8000+  - write mapper regs
#   Believe it or not, some games actually do this to write to the mapper.
#   Why?  Although it doesn't save any clock cycles, it does save a byte
#   of memory compared to the usual LDA/STA method.
ee 00/00 80/80,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	83 c6 06                # addl   $0x6,%esi
	50                      # pushl  %eax
	0f b6 83 [W+1] 00 00    # movzbl ADDR(%ebx),%eax
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	40                      # incl   %eax
	0f be f8                # movsbl %al,%edi
	e8 [Y]                  # call   MAPPER
	58                      # popl   %eax
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# DEC $8000+  - write mapper regs
ce 00/00 80/80,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	83 c6 06                # addl   $0x6,%esi
	50                      # pushl  %eax
	0f b6 83 [W+1] 00 00    # movzbl ADDR(%ebx),%eax
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	48                      # decl   %eax
	0f be f8                # movsbl %al,%edi
	e8 [Y]                  # call   MAPPER
	58                      # popl   %eax
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# INC $8000+,X to mapper
fe 00/00 80/80,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c6 07                # addl   $0x7,%esi
	8d b9 [W+1] 00 00       # leal   ADDR(%ecx),%edi
	50                      # pushl  %eax
	89 fb                   # movl   %edi,%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0f b6 04 1f             # movzbl (%edi,%ebx,1),%eax
	40                      # incl   %eax
	0f be f8                # movsbl %al,%edi
	e8 [Y]                  # call   MAPPER
	58                      # popl   %eax
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# DEC $8000+,X to mapper
de 00/00 80/80,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c6 07                # addl   $0x7,%esi
	8d b9 [W+1] 00 00       # leal   ADDR(%ecx),%edi
	50                      # pushl  %eax
	89 fb                   # movl   %edi,%ebx
	c1 ef 0c                # shrl   $0xc,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0f b6 04 1f             # movzbl (%edi,%ebx,1),%eax
	48                      # decl   %eax
	0f be f8                # movsbl %al,%edi
	e8 [Y]                  # call   MAPPER
	58                      # popl   %eax
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/


#-----------------------------------------------------------------------------
# Special Cases for I/O

# LDA $2002 - PPU Status Register [PPUSTAT]
ad 02 20,3:
	8d 76 04                # leal   0x4(%esi),%esi # do timing count
	bb 02 20 00 00          # movl   $0x2002,%ebx
	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/
# LDX $2002 - PPU Status Register [PPUSTAT]
ae 02 20,3:
	8d 76 04                # leal   0x4(%esi),%esi # do timing count
	bb 02 20 00 00          # movl   $0x2002,%ebx
	e8 [I]                  # call   INPUT
	89 f9                   # movl   %edi,%ecx
	/
# LDY $2002 - PPU Status Register [PPUSTAT]
ac 02 20,3:
	8d 76 04                # leal   0x4(%esi),%esi # do timing count
	bb 02 20 00 00          # movl   $0x2002,%ebx
	e8 [I]                  # call   INPUT
	89 fa                   # movl   %edi,%edx
	/
# BIT $2002 (Test PPU status)
2c 02 20,3:
	0d 00 ff ff ff          # orl    $0xffffff00,%eax
	bb 02 20 00 00          # movl   $0x2002,%ebx
	e8 [I]                  # call   INPUT
	8d 1c 3f                # leal   (%edi,%edi,1),%ebx
	81 e3 80 00 00 00       # andl   $0x80,%ebx
	89 1d [V]               # movl   %ebx,VFLAG
	21 c7                   # andl   %eax,%edi
	83 c6 04                # addl   $4,%esi
	/

# LDA $2007 - Read VRAM
ad 07 20,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb 07 20 00 00          # movl   $0x2007,%ebx
	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/
# LDX $2007
ae 07 20,3:
	8d 76 04                # leal   0x4(%esi),%esi # do timing count
	bb 07 20 00 00          # movl   $0x2007,%ebx
	e8 [I]                  # call   INPUT
	89 f9                   # movl   %edi,%ecx
	/
# LDY $2007
ac 07 20,3:
	8d 76 04                # leal   0x4(%esi),%esi # do timing count
	bb 07 20 00 00          # movl   $0x2007,%ebx
	e8 [I]                  # call   INPUT
	89 fa                   # movl   %edi,%edx
	/

# ADC $2007
6d 07 20,3:
	0f be c0                # movsbl %al,%eax
	bb 07 20 00 00          # movl   $0x2007,%ebx
	e8 [I]                  # call   INPUT
	83 c5 ff                # addl   $0xffffffff,%ebp
	11 f8                   # adcl   %edi,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	19 ed                   # sbbl   %ebp,%ebp
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	/

# LDA $40xx - I/O read
ad 00/00 40,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/
# AND $40xx - I/O read
2d 00/00 40,3:
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	0f be c0                # movsbl %al,%eax
	8d 76 04                # leal   0x4(%esi),%esi
	e8 [I]                  # call   INPUT
	21 c7                   # andl   %eax,%edi
	89 f8                   # movl   %edi,%eax
	/
# LDA $40xx,x - I/O read
bd 00/00 40,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	8d 76 04                # leal   0x4(%esi),%esi #timing
	01 cb                   # addl   %ecx,%ebx
	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/
# LDA $40xx,y - I/O read
b9 00/00 40,3:
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	8d 76 04                # leal   0x4(%esi),%esi
	8d 9a [W+1] 00 00       # leal   $ADDR(%edx),%ebx
	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/


# Output

# STA $2000  - write to $2000
8d 00 20,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	/
# STX $2000  - write to $2000
8e 00 20,3:
	91                      # xchgl  %eax,%ecx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2000,%ebx
	e8 [O]                  # call   OUTPUT
	91                      # xchgl  %eax,%ecx
	/
# STY $2000  - write to $2000
8c 00 20,3:
	92                      # xchgl  %eax,%edx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2000,%ebx
	e8 [O]                  # call   OUTPUT
	92                      # xchgl  %eax,%edx
	/

# STA $2001  - write to $2001
8d 01 20,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	/
# STX $2001  - write to $2001
8e 01 20,3:
	91                      # xchgl  %eax,%ecx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2001,%ebx
	e8 [O]                  # call   OUTPUT
	91                      # xchgl  %eax,%ecx
	/
# STY $2001  - write to $2001
8c 01 20,3:
	92                      # xchgl  %eax,%edx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2001,%ebx
	e8 [O]                  # call   OUTPUT
	92                      # xchgl  %eax,%edx
	/

# STA $2002  - write to $2002?? should not happen
8d 02 20,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
#	bb [W+1] 00 00          # movl   $ADDR,%ebx
#	e8 [O]                  # call   OUTPUT
	/

# STA $2003  - write to $2003
8d 03 20,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	/
# STX $2003  - write to $2003
8e 03 20,3:
	91                      # xchgl  %eax,%ecx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2003,%ebx
	e8 [O]                  # call   OUTPUT
	91                      # xchgl  %eax,%ecx
	/
# STY $2003  - write to $2003
8c 03 20,3:
	92                      # xchgl  %eax,%edx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2003,%ebx
	e8 [O]                  # call   OUTPUT
	92                      # xchgl  %eax,%edx
	/

# STA $2004  - write to $2004
8d 04 20,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	/
# STX $2004  - write to $2004
8e 04 20,3:
	91                      # xchgl  %eax,%ecx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2004,%ebx
	e8 [O]                  # call   OUTPUT
	91                      # xchgl  %eax,%ecx
	/
# STY $2004  - write to $2004
8c 04 20,3:
	92                      # xchgl  %eax,%edx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2004,%ebx
	e8 [O]                  # call   OUTPUT
	92                      # xchgl  %eax,%edx
	/

# STA $2005  - write to $2005
8d 05 20,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	/
# STX $2005  - write to $2005
8e 05 20,3:
	91                      # xchgl  %eax,%ecx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2005,%ebx
	e8 [O]                  # call   OUTPUT
	91                      # xchgl  %eax,%ecx
	/
# STY $2005  - write to $2005
8c 05 20,3:
	92                      # xchgl  %eax,%edx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $0x2005,%ebx
	e8 [O]                  # call   OUTPUT
	92                      # xchgl  %eax,%edx
	/

# STA $2006  - write to $2006
8d 06 20,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	/
# STX $2006  - write to $2006
8e 06 20,3:
	8d 76 04                # leal   0x4(%esi),%esi
	91                      # xchgl  %eax,%ecx
	bb 06 20 00 00          # movl   $0x2006,%ebx
	e8 [O]                  # call   OUTPUT
	91                      # xchgl  %eax,%ecx
	/
# STY $2006  - write to $2006
8c 06 20,3:
	8d 76 04                # leal   0x4(%esi),%esi
	92                      # xchgl  %eax,%edx
	bb 06 20 00 00          # movl   $0x2006,%ebx
	e8 [O]                  # call   OUTPUT
	92                      # xchgl  %eax,%edx
	/

# STA $2007  - write to $2007
8d 07 20,3:
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	8d 76 04                # leal   0x4(%esi),%esi
	e8 [O]                  # call   OUTPUT
	/
# STX $2007  - write to $2007
8e 07 20,3:
	8d 76 04                # leal   0x4(%esi),%esi
	91                      # xchgl  %eax,%ecx
	bb 07 20 00 00          # movl   $0x2007,%ebx
	e8 [O]                  # call   OUTPUT
	91                      # xchgl  %eax,%ecx
	/
# STY $2007  - write to $2007
8c 07 20,3:
	8d 76 04                # leal   0x4(%esi),%esi
	92                      # xchgl  %eax,%edx
	bb 07 20 00 00          # movl   $0x2007,%ebx
	e8 [O]                  # call   OUTPUT
	92                      # xchgl  %eax,%edx
	/

# STA $40xx - I/O write
8d 00/00 40,3:
	8d 76 04                # leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	/
# STX $40xx - I/O write
8e 00/00 40,3:
	91                      # xchgl  %eax,%ecx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	91                      # xchgl  %eax,%ecx
	/
# STY $40xx - I/O write
8c 00/00 40,3:
	92                      # xchgl  %eax,%edx
	8d 76 04                # leal   0x4(%esi),%esi
	bb [W+1] 00 00          # movl   $ADDR,%ebx
	e8 [O]                  # call   OUTPUT
	92                      # xchgl  %eax,%edx
	/


# Indexed output

# STA $40xx,X
9d 00/00 40,3:
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	83 c6 05                # addl   $0x5,%esi
	8d 99 [W+1] 00 00       # leal   ADDR(%ecx),%ebx
	e8 [O]                  # call   OUTPUT
	/
# STA $40xx,Y
99 00/00 40,3:
	81 e2 ff 00 00 00       # andl   $0xff,%edx
	83 c6 05                # addl   $0x5,%esi
	8d 9a [W+1] 00 00       # leal   ADDR(%edx),%ebx
	e8 [O]                  # call   OUTPUT
	/
