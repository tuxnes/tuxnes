#
# This file is part of the TuxNES project codebase.
#
# Please see the README and COPYING files for more information regarding
# this project.
#
#
# Description: Translation tables for 6502 to x86 dynamic recompiler

# This is the translation table for converting 6502 code into native code
# for x86 processors.  I have used the GNU standard for the representation
# of operands, which is: source,destination.  Be aware that Intel uses the
# opposite ordering in their documentation (destination preceeds source).
# 
# I have adopted the following register usage conventions:
# 
#      A -> %eax            Carry flag -> %ebp
#      X -> %ecx     Zero & Sign flags -> %edi
#      Y -> %edx           Cycle count -> %esi
# 
# The stack pointer and remaining flags are stored in memory.  The 6502
# program counter is loaded into %ebx when a branch occurs; at all other
# times, %ebx is used to hold various temporary values.  The carry flag
# is stored by setting %ebp to a nonzero value.  The %esi register is
# incremented to represent the 6502 cycle count.
# 
# %edi is used to store the sign and zero flags.  This is usually done by
# sign-extending the result of arithmetic operations into %edi.  The
# equivilence branch instructions check the lower 8 bits of %edi against
# zero, and the sign branch instructions check bit 8 (0x100) of %edi.  While
# in many cases it would be sufficient to check only bit 7 to determine
# the sign, some 6502 instructions (such as BIT) can set the sign and zero
# flags independently, so a mechanism must be provided to accomodate this.
# Sign extension unfortunately is relatively slow (3 cycles) on a Pentium
# processor.  An alternative would be to store the sign and zero flags in
# seperate memory locations, but as this would also require additional CPU
# cycles to read/write memory, I see little advantage in this approach,
# especially considering that the sign-extension can be precomputed for
# immediate data, thus eliminating the 3-cycle penalty for most data load
# operations.  
# 
# This file consists of a substitution table for replacing 6502 code with
# native equivilents.  The format is as follows:
# 
# (6502 instruction bytes),length:  (native instruction bytes) /
# 
# Each statement may span multiple lines and is terminated with a single
# slash mark.  All values are in hexadecimal.  The compdata.c program parses
# this file and compiles it into a binary search tree which is then linked
# into the final executable.  Anything following a # mark (such as this text)
# is ignored by the compiler.
# 
# The source bytes may contain a pattern to be matched using an and-mask,
# which follows the instruction byte and a slash.  For example:
# 80/80 matches any value with the high bit set, 00/01 matches any even
# number, and 00/00 matches anything.
# 
# The compiler can evaluate the following expressions in generating the
# translated code:
# 
# [B+n] Byte at SRC+n, where SRC is the address of the 6502 instruction
# [C+n] Bitwise compliment of byte at SRC+n
# [W+n] 16-bit word at SRC+n
# [E+n] Byte at PC+n sign-extended to doubleword
# [Z+n] Zero Page Pointer to addr byte at SRC+n
# [A+n] Absolute address (word16 at SRC+n -> RAM address)
# [R+n] Relative branch address (byte at SRC+n converted to target address)
# [P+n] Current 6502 program counter +n (word16)
# [X+n] Precalculated remap table address for word16 at SRC+n
# [D+n] Destination address of translated code +n
# [>+n] Cycle count adjust (+1) for branch at SRC+n
# [V]   V-flag storage location
# [F]   Other flags storage location (process status register)
# [S]   Stack Pointer
# [T]   Top of stack (lowest address)
# [L]   Base of RAM (lowest address)
# [M]   Base address of mapper table
# [N]   Address of NMI/IRQ/refresh handler
# [I]   Address of Input handler
# [O]   Address of Output handler
# [U]   Address to jmp to go to unresolved address
# [Y]   Address to call remapper
# [!]   Stop translating
# [^]   Insert breakpoint/trap
# 
# To write to an output register, the generated code should put the location
# into %ebx and the value to write in %eax, and call [O].  (The compiler will
# replace [O] with the proper address.)  To read an input register, place the
# location into %ebx and call [I].  The value is returned in %edi.  For
# writes into the ROM area, call [Y] to pass these values to the mapper.
# 
# Reads of memory are redirected thru the mapper table.  This table consists
# of 16 entries, each representing 4K of memory in the 6502 address space
# and containing a pointer to the actual memory location where the data can
# be found.  This table is used to emulate the function of the mapper chips
# found in many game cartridges.
# 
# To execute a jump to a 6502 address, load the address into %ebx and jump
# to [U].  Also load the address of the operand of the jump instruction into
# %esp-4; that is, put it on top of the stack without modifying the stack
# pointer.  The Update function will translate any new code if necessary and
# resolve the 6502 target address into a native 32-bit address.  It will
# then use the value at %esp-4 to update the jump instruction to point to
# the new location.  For indirect jumps which can not be predicted, zero
# should be loaded into %esp-4, and the address will not be modified.  This
# may also be necessary if the target of the jump is swapped by the mapper.
# 
# The %esi register is constantly incremented to reflect the 6502 cycle count.
# When this register exceeds 0xFFFFFFFF and wraps around, the program should
# jump to the NMI function [N].  This is done whether interrupts are enabled
# or not - this function updates the screen display and then generates a
# vblank NMI if appropriate.  In some cases the interrupt to be generated is
# actually an IRQ and not an NMI, but these are treated the same; the [N]
# function will determine which interrupt to generate, if any. (see x86.S)
# 
# Note that this file is parsed beginning to end, with later statements
# overriding previous ones.  Therefore, general cases are defined first, and
# special cases last.
# 
# Thanks to Matt Ghio for assembler coding help.
# 
# Basic NES Memory Map:
#
# 0000-0800 - NES internal RAM
# 2000-2007 - I/O register area 1 (see io.c)
# 4000-4015 - I/O register area 2 (see io.c)
# 6000-7FFF - Nonvolitile RAM for save data
# 8000-FFFF - Reads ROM, writes output to mapper (see mapper.c)


# 00 - BRK
00,1:
	8b 1d [S]		# movl   [S],%ebx
	50			# pushl  %eax
	b8 [P+2]		# movl   $[P+2],%eax
	88 23			# movb   %ah,(%ebx)
	4b			# decl   %ebx
	81 cb 00 01 00 00	# orl    $0x100,%ebx
	88 03			# movb   %al,(%ebx)
	fe cb			# decb   %bl
	a1 [F]			# movl   [F],%eax
	88 1d [S]		# movb   %bl,[S]
	83 e0 3C   	    	# andl   $0x3C,%eax
	31 db	          	# xorl   %ebx,%ebx
	83 c8 14	       	# orl    $0x14,%eax
	83 c5 ff		# addl   $0xffffffff,%ebp
	89 c5			# movl   %eax,%ebp
	a3 [F]			# movl   %eax,[F]
	58			# popl   %eax
	83 d5 00		# adcl   $0x0,%ebp
	f7 c7 ff 00 00 00	# testl  $0xff,%edi
	0f 94 c3		# setz   %bl
	8d 6c 5d 00		# leal   0x0(%ebp,%ebx,2),%ebp
	89 fb			# movl   %edi,%ebx
	d1 eb			# shrl   %ebx
	81 e3 80 00 00 00	# andl   $0x80,%ebx
	09 dd			# orl    %ebx,%ebp
	8b 1d [V]		# movl   [V],%ebx
	81 c3 80 00 00 00	# addl   $0x80,%ebx
	81 c3 00 ff ff ff	# addl   $0xffffff00,%ebx
	19 db			# sbbl   %ebx,%ebx
	83 e3 40		# andl   $0x40,%ebx
	09 eb			# orl    %ebp,%ebx
	8b 2d [S]		# movl   [S],%ebp
	88 5d 00		# movb   %bl,(%ebp)
	83 e3 01		# andl   $0x1,%ebx
	fe 0d [S]		# decb   [S]
	89 dd			# movl   %ebx,%ebp
	83 c6 07		# addl   $0x7,%esi
	bb [M]			# movl   $[M],%ebx
	8b 5b 3c		# movl   0x3c(%ebx),%ebx
	0f b7 9b fe ff 00 00	# movzwl 0xfffe(%ebx),%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0x0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	[!]			#  -STOP-
	/
# 01 - ORA - (Indirect,X)
01,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	31 db			# xorl   %ebx,%ebx
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	66 8b 9f [L]		# movw   RAM(%edi),%bx

# FIXME - trap I/O
 8d bb 00 e0 ff ff	# leal   0xffffe000(%ebx),%edi
 81 ff 00 40 00 00	# cmpl   $0x4000,%edi
 73 01			# jae    +1
 [^]			# int3

	89 df			# movl   %ebx,%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	8d 76 06		# leal   6(%esi),%esi
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx
	0a 04 1f		# orb    (%edi,%ebx,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 02 - (bad)
# 03 - (bad)
# 04 - (bad)
# 05 - ORA - Zero Page    
05,2:
	0b 05 [Z+1]		# orl    ZP,%eax
	83 c6 03		# addl   $0x3,%esi
	0f be f8		# movsbl %al,%edi
	/
# 06 - ASL - Zero Page    
06,2:
        31 db			# xorl   %ebx,%ebx
	8a 1d [Z+1]		# movb   ZP,%bl
	00 db			# addb   %bl,%bl
	8d 76 05		# leal   0x5(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	88 1d [Z+1]		# movb   %bl,ZP
	0f be fb		# movsbl %bl,%edi
	/
# 07 - (bad)   
# 08 - PHP
08,1:
        83 25 [F] 3C      	# andl   $0x3C,F
        31 db             	# xorl   %ebx,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	8b 2d [F]		# movl   FLAGS,%ebp
	83 d5 00		# adcl   $0x0,%ebp
        f7 c7 ff 00 00 00 	# testl  $0xff,%edi
	0f 94 c3		# setz   %bl
	8d 76 03		# leal   0x3(%esi),%esi
	8d 6c 5d 00		# leal   0x0(%ebp,%ebx,2),%ebp
        89 fb			# movl   %edi,%ebx
	83 cd 20		# orl    $0x20,%ebp
        d1 eb			# shrl   %ebx
	81 e3 80 00 00 00	# andl   $0x80,%ebx
	09 dd			# orl    %ebx,%ebp
	8b 1d [V]		# movl   [V],%ebx
        81 c3 80 00 00 00	# addl   $0x80,%ebx
        81 c3 00 ff ff ff	# addl   $0xffffff00,%ebx
        19 db			# sbbl   %ebx,%ebx
        83 e3 40		# andl   $0x40,%ebx
        09 eb			# orl    %ebp,%ebx
        8b 2d [S]		# movl   S,%ebp
        88 5d 00		# movb   %bl,0x0(%ebp)
        83 e3 01		# andl   $0x1,%ebx
        fe 0d [S]		# decb   S  
        89 dd			# movl   %ebx,%ebp
	/
# 09 - ORA - Immediate    
09,2:
	83 c8 [B+1]		# orl    $B+1,%eax
	83 c6 02		# addl   $0x2,%esi
	0f be f8		# movsbl %al,%edi
	/
# 0A - ASL - Accumulator  
0A,1:
	00 c0			# addb   %al,%al
	8d 76 02		# leal   0x2(%esi),%esi
        19 ed			# sbbl   %ebp,%ebp
	0f be f8		# movsbl %al,%edi
	/
# 0B - (bad)   
# 0C - (bad)   
# 0D - ORA - Absolute     
0D,3:
	8b 1d [X+1]		# movl   XLATADDR,%ebx
	83 c6 04		# addl   $0x4,%esi
	0a 83 [W+1] 00 00	# orb    ADDR(%ebx),%al
	0f be f8		# movsbl %al,%edi
	/
# 0E - ASL - Absolute     
0E,3:
# Warning - doesn't check mapper
	31 db			# xorl   %ebx,%ebx
	8a 1d [A+1]		# movb   ADDR,%bl
	00 db			# addb   %bl,%bl
	8d 76 06		# leal   0x6(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	88 1d [A+1]		# movb   %bl,ADDR
	0f be fb		# movsbl %bl,%edi
	/
# 0F - (bad)   
# 10 - BPL                
10,2: 
	83 c6 [>+1] 03		# addl   $3+,%esi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	f7 c7 00 01 00 00	# testl  $0x100,%edi
	bb [R+1]		# movl   $[R+1],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 84 [U]		# je     U
	83 ee [>+1] 01		# subl   $1+,%esi
        /
# 11 - ORA - (Indirect),Y
11,2:
	31 db			# xorl   %ebx,%ebx
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	66 8b 1d [Z+1]		# movw   ZP,%bx
	8d 3c 1a		# leal   (%edx,%ebx,1),%edi
	8d 1c 1a		# leal   (%edx,%ebx,1),%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	8d 76 05		# leal   0x5(%esi),%esi
	8b 3c bd [M]		# movl   MAPTABLE(,%edi,4),%edi

# FIXME - trap I/O
 81 fb 00 60 00 00 # cmpl   $0x6000,%ebx
 73 09             # jae    +9
 81 fb 00 20 00 00 # cmpl   $0x2000,%ebx
 72 01             # jb     +1
 [^]               # int3   

	0a 04 1f		# orb    (%edi,%ebx,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 12 - (bad)   
# 13 - (bad)   
# 14 - (bad)   
# 15 - ORA - Zero Page,X  
15,2:
	8d 59 [B+1]		# leal   operand(%ecx),%ebx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	83 c6 04		# addl   $0x4,%esi
	0b 83 [L]		# orl    RAM(%ebx),%eax
	0f be f8		# movsbl %al,%edi
	/
# 16 - ASL - Zero Page,X  
16,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	31 db			# xorl   %ebx,%ebx
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	8d 76 06		# leal   6(%esi),%esi
	8a 9f [L]		# movb   ZP(%edi),%bl
	00 db			# addb   %bl,%bl
	19 ed			# sbbl   %ebp,%ebp
	88 9f [L]		# movb   %bl,ZP(%edi)
	0f be fb		# movsbl %bl,%edi
	/
# 17 - (bad)   
# 18 - CLC                
18,1:
	31 ed			# xorl   %ebp,%ebp
	83 c6 02		# addl   $0x2,%esi
	/
# 19 - ORA - Absolute,Y   
19,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	8d ba [W+1] 00 00	# leal   ADDR(%edx),%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx
	0a 04 3b		# orb    (%ebx,%edi,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 1A - (bad)   
# 1B - (bad)   
# 1C - (bad)   
# 1D - ORA - Absolute,X   
1D,3:
# FIXME - cycle count wrong
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	8d b9 [W+1] 00 00	# leal   ADDR(%ecx),%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx
	0a 04 3b		# orb    (%ebx,%edi,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 1E - ASL - Absolute,X
1E,3:
# warning: assumes RAM target; doesn't check ROM mapper or FFFF->0000 overflow
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c6 07		# addl   $0x7,%esi        (cycle count +7)
	d0 a1 [A+1]		# shlb   [A+1](%ecx)
	19 ed			# sbbl   %ebp,%ebp        (saves carry flag)
	0f be b9 [A+1]		# movsbl [A+1](%ecx),%edi (saves other flags)
	/
# 1F - (bad)
# 20 - JSR
20,3:
	8b 1d [S]		# movl   S,%ebx
	50			# pushl  %eax
	b8 [P+2]		# movl   $[P+2],%eax
	88 23			# movb   %ah,(%ebx)
	4b			# decl   %ebx
	81 cb 00 01 00 00	# orl    $0x100,%ebx
	88 03			# movb   %al,(%ebx)
	fe cb			# decb   %bl
	83 c6 06		# addl   $0x6,%esi
	58			# popl   %eax
	88 1d [S]		# movb   %bl,S
	bb [W+1] 00 00		# movl   $0000[W+1],%ebx
	0f 89 [N]		# jns    NMI
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    UPDATE/COMPILE
	[!]			#  -STOP-
# It's fairly common for 6502 code to follow a JSR with parameter data,
# so there's a chance that what follows is not executable code, in which
# case translation should stop after the JSR.
	/
# 21 - AND - (Indirect,X)
# 22 - (bad)
# 23 - (bad)
# 24 - BIT - Zero Page
24,2:
	0f be 3d [Z+1]		# movsbl ZP,%edi
	0d 00 01 00 00		# orl    $0x100,%eax
	83 c6 03		# addl   $0x3,%esi
	8d 1c fd 00 00 00 00	# leal   0x0(,%edi,8),%ebx
	21 c7			# andl   %eax,%edi
	81 e3 00 02 00 00	# andl   $0x200,%ebx
	89 1d [V]		# movl   %ebx,VFLAG
        /
# 25 - AND - Zero Page
25,2:
        23 05 [Z+1]		# andl   ZP,%eax
	83 c6 03		# addl   $3,%esi
	0f be f8		# movsbl %al,%edi
	/
# 26 - ROL - Zero Page
26,2:
	83 c5 ff		# addl   $0xffffffff,%ebp
	d0 15 [Z+1]		# rclb   ZP
	8d 76 05		# leal   5(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	0f be 3d [Z+1]		# movsbl ZP,%edi
	/
# 27 - (bad)
# 28 - PLP
28,1:
        8b 3d [S]           # movl   S,%edi
        81 ef ff 00 00 00   # subl   $0xff,%edi
        81 cf 00 01 00 00   # orl    $0x100,%edi
        89 3d [S]           # movl   %edi,S
        8b 1f               # movl   (%edi),%ebx
	8d 76 04	    # leal   0x4(%esi),%esi
        89 dd               # movl   %ebx,%ebp
        83 e5 3C            # andl   $0x3C,%ebp
        8d 3c dd 00 00 00 00# leal   0x0(,%ebx,8),%edi
        83 f3 02            # xorl   $0x2,%ebx
        89 2d [F]           # movl   %ebp,F
        89 dd               # movl   %ebx,%ebp
        81 e7 00 02 00 00   # andl   $0x200,%edi
        83 e5 01            # andl   $0x1,%ebp
        89 3d [V]           # movl   %edi,V
	8d 3c 1b	    # leal   (%ebx,%ebx,1),%edi
	81 e7 04 01 00 00   # andl   $0x104,%edi
	/
# 29 - AND - Immediate
29,2:
	25 [B+1] 00 00 00	# andl   $0x000000[B+1],%eax
	83 c6 02		# addl   $0x2,%esi
	0f be f8		# movsbl %al,%edi
#Alternate form does same thing:
#	25 [B+1] 00 00 00	# andl   $0x000000[B+1],%eax
#	83 c0 80		# addl   $0xffffff80,%eax
#	83 c6 02		# addl   $0x2,%esi
#	83 f0 80		# xorl   $0xffffff80,%eax
#	89 c7			# movl   %eax,%edi
	/
# 2A - ROL - Accumulator
2A,1:
	83 c5 ff		# addl   $0xffffffff,%ebp
	d0 d0			# rclb   %al
	8d 76 02		# leal   2(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	0f be f8		# movsbl %al,%edi
	/
# 2B - (bad)
# 2C - BIT - Absolute
2C,3: 
	8b 1d [X+1]		# movl   XADDRMAP,%ebx
	0d 00 01 00 00		# orl    $0x100,%eax
	0f be bb [W+1] 00 00	# movsbl ADDR(%ebx),%edi
	83 c6 04		# addl   $0x4,%esi
	8d 1c fd 00 00 00 00	# leal   0x0(,%edi,8),%ebx
	21 c7			# andl   %eax,%edi
	81 e3 00 02 00 00	# andl   $0x200,%ebx
	89 1d [V]		# movl   %ebx,VFLAG
        /
# 2D - AND - Absolute
2D,3:
	8b 1d [X+1]		# movl   XMAPADDR,%ebx
	83 c6 04		# addl   $0x4,%esi
	22 83 [W+1] 00 00	# andb   ADDR(%ebx),%al
	0f be f8		# movsbl %al,%edi
	/
# 2E - ROL - Absolute
2E,3:
#warning - assumes ram target, doesn't check mapper
	83 c5 ff	# addl   $0xffffffff,%ebp
	d0 15 [A+1]	# rclb   ADDR
	8d 76 06	# leal   6(%esi),%esi
	19 ed		# sbbl   %ebp,%ebp
	0f be 3d [A+1]	# movsbl ADDR,%edi
	/
# 2F - (bad)
# 30 - BMI
30,2:
	83 c6 [>+1] 03		# addl   $3+,%esi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	f7 c7 00 01 00 00	# testl  $0x100,%edi
	bb [R+1]		# movl   $[R+1],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 85 [U]		# jne    U
	83 ee [>+1] 01		# subl   $1+,%esi
        /
# 31 - AND - (Indirect),Y
31,2:
	31 db			# xorl   %ebx,%ebx
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	66 8b 1d [Z+1]		# movw   [Z+1],%bx
	01 d3			# addl   %edx,%ebx

# FIXME - trap I/O
 8d bb 00 e0 ff ff	# leal   0xffffe000(%ebx),%edi
 81 ff 00 40 00 00	# cmpl   $0x4000,%edi
 73 01			# jae    +1
 [^]			# int3

	89 df			# movl   %ebx,%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx
	83 c6 05		# addl   $0x5,%esi
	22 04 3b		# andb   (%ebx,%edi,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 32 - (bad)
# 33 - (bad)
# 34 - (bad)
# 35 - AND - Zero Page,X
35,2:
	8d 59 [B+1]		# leal   operand(%ecx),%ebx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	83 c6 04		# addl   $0x4,%esi
	23 83 [L]		# andl   RAM(%ebx),%eax
#				#andb..?
	0f be f8		# movsbl %al,%edi
	/
# 36 - ROL - Zero Page,X
36,2:
	8d 59 [B+1]		# leal   [B+1](%ecx),%ebx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	d0 93 [L]		# rclb   RAM(%ebx)
	8d 76 06		# leal   6(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	0f be bb [L]		# movsbl RAM(%ebx),%edi
	/
# 37 - (bad)
# 38 - SEC
38,1:
	83 c6 02		# addl   $0x2,%esi
	83 cd ff		# orl    $0xffffffff,%ebp
	/

# 39 - AND - Absolute,Y
39,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	c1 eb 0c		# shrl   $0xc,%ebx
	8d ba [W+1] 00 00	# leal   ADDR(%edx),%edi
	83 c6 04		# addl   $0x4,%esi
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx
	22 04 3b		# andb   (%ebx,%edi,1),%al
	0f be f8		# movsbl %al,%edi 
	/
# 3A - (bad)
# 3B - (bad)
# 3C - (bad)
# 3D - AND - Absolute,X
3D,3:
# FIXME - cycle count wrong
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	c1 eb 0c		# shrl   $0xc,%ebx
	8d b9 [W+1] 00 00	# leal   ADDR(%ecx),%edi
	83 c6 04		# addl   $0x4,%esi
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx
	22 04 3b		# andb   (%ebx,%edi,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 3E - ROL - Absolute,X
3E,3:
# warning: assumes RAM target; doesn't check ROM mapper!
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c5 ff		# addl   $0xffffffff,%ebp
	8d 76 07		# leal   7(%esi),%esi
	d0 91 [A+1]		# rclb   ADDR(%ecx)
	19 ed			# sbbl   %ebp,%ebp       (saves carry flag)
	0f be b9 [A+1]		# movsbl ADDR(%ecx),%edi (saves other flags)
	/
# 3F - (bad)
# 40 - RTI
40,1:
	8b 3d [S]  		# movl   STACKPTR,%edi
	81 ef ff 00 00 00	# subl   $0xff,%edi
	81 cf 00 01 00 00	# orl    $0x100,%edi
	89 3d [S]		# movl   %edi,STACKPTR
	8b 1f			# movl   (%edi),%ebx
	89 dd			# movl   %ebx,%ebp
	83 e5 3C		# andl   $0x3C,%ebp
	8d 3c dd 00 00 00 00	# leal   0x0(,%ebx,8),%edi
	83 f3 02		# xorl   $0x2,%ebx
	89 2d [F]		# movl   %ebp,FLAGS
	89 dd			# movl   %ebx,%ebp
	81 e7 00 02 00 00	# andl   $0x200,%edi
	83 e5 01		# andl   $0x1,%ebp
	89 3d [V]	 	# movl   %edi,VFLAG
	8d 3c 5d 00 00 00 00	# leal   0x0(,%ebx,2),%edi
	81 e7 04 01 00 00	# andl   $0x104,%edi
	31 db			# xorl   %ebx,%ebx
	8a 1d [S]		# movb   STACKPTR,%bl
	fe c3			# incb   %bl
	8a ab [T]		# movb   STACK(%ebx),%ch
	fe c3			# incb   %bl
	8a b3 [T]		# movb   STACK(%ebx),%dh
	88 1d [S]		# movb   %bl,STACKPTR
	31 db			# xorl   %ebx,%ebx
	86 eb			# xchgb  %ch,%bl
	86 f7			# xchgb  %dh,%bh
	83 c6 06		# addl   $0x6,%esi
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	[!]
	/
# 41 - EOR - (Indirect,X) 
# 42 - (bad)   
# 43 - (bad)   
# 44 - (bad)   
# 45 - EOR - Zero Page    
45,2:
        33 05 [Z+1]		# xorl   Z,%eax
	83 c6 03		# addl   $0x3,%esi
	0f be f8		# movsbl %al,%edi
	/
# 46 - LSR - Zero Page    
46,2:
	31 db			# xorl   %ebx,%ebx
	8a 1d [Z+1]		# movb   ZP,%bl
	d0 eb			# shrb   %bl
	8d 76 05		# leal   0x5(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	88 1d [Z+1]		# movb   %bl,ZP
	89 df			# movl   %ebx,%edi
	/
# 47 - (bad)   
# 48 - PHA                
48,1:
	8b 1d [S]		# movl   STACKPTR,%ebx
	83 c6 03		# addl   $0x3,%esi
	88 03			# movb   %al,(%ebx)
	fe cb			# decb   %bl
	88 1d [S]		# movb   %bl,STACKPTR
	/
# 49 - EOR - Immediate    
49,2:
	35 [E+1]		# xorl   $imm,%eax
	83 c6 02		# addl   $0x2,%esi
	0f be f8		# movsbl %al,%edi
	/
# 4A - LSR - Accumulator  
4A,1:
        d1 e8			# shrl   %eax
        19 ed			# sbbl   %ebp,%ebp
        83 e0 7f		# andl   $0x7f,%eax
	8d 76 02		# leal   0x2(%esi),%esi
	89 c7			# movl   %eax,%edi
	/
# 4B - (bad)   
# 4C - JMP - Absolute     
4C,3:
	83 c6 03		# addl   $3,%esi
	bb [W+1] 00 00		# movl   $0000[W+1],%ebx
	0f 89 [N]		# jns    NMI
	81 fb [P]		# cmpl   $[P],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 85 [U]		# jne    [U]
	31 f6			# xorl   %esi,%esi
	e9 [N]			# jmp    NMI
	[!]
	/
# 4D - EOR - Absolute     
4D,3:
	8b 1d [X+1]		# movl   XMAPADDR,%ebx
	83 c6 04		# addl   $0x4,%esi
	32 83 [W+1] 00 00	# xorb   ADDR(%ebx),%al
	0f be f8		# movsbl %al,%edi
	/
# 4E - LSR - Absolute     
4E,3:
# Warning: read-modify-write operation assumes RAM target, does not check mapper table
	8b 1d [A+1]		# movl   ADDR,%ebx
	d1 eb			# shrl   %ebx
	19 ed			# sbbl   %ebp,%ebp
	83 e3 7f		# andl   $0x7f,%ebx
	8d 76 06		# leal   6(%esi),%esi
	88 1d [A+1]		# movb   %bl,ADDR
	89 df			# movl   %ebx,%edi
	/
# 4F - (bad)   
# 50 - BVC
50,2:
	83 c6 [>+1] 03		# addl   $3+,%esi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	8b 1d [V]		# movl   [V],%ebx
	81 c3 80 00 00 00	# addl   $0x80,%ebx
	f7 c3 00 ff ff ff	# testl  $0xffffff00,%ebx
	bb [R+1]		# movl   $[R+1],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 84 [U]		# je     U
	83 ee [>+1] 01		# subl   $1+,%esi
	/
# 51 - EOR - (Indirect),Y 
51,2:
	31 db			# xorl   %ebx,%ebx
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	66 8b 1d [Z+1]		# movw   [Z+1],%bx
	8d 76 05		# leal   0x5(%esi),%esi
	8d 3c 1a		# leal   (%edx,%ebx,1),%edi
	c1 ef 0c		# shrl   $0xc,%edi
	8d 1c 1a		# leal   (%edx,%ebx,1),%ebx

# FIXME - trap I/O
 81 fb 00 60 00 00 # cmpl   $0x6000,%ebx
 73 09             # jae    +9
 81 fb 00 20 00 00 # cmpl   $0x2000,%ebx
 72 01             # jb     +1
 [^]               # int3   

	8b 3c bd [M]		# movl   [M](,%edi,4),%edi
	32 04 3b		# xorb   (%ebx,%edi,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 52 - (bad)   
# 53 - (bad)   
# 54 - (bad)   
# 55 - EOR - Zero Page,X  
55,2:
	8d 59 [B+1]		# leal   operand(%ecx),%ebx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	83 c6 04		# addl   $0x4,%esi
	33 83 [L]		# xorl   RAM(%ebx),%eax
	0f be f8		# movsbl %al,%edi
	/
# 56 - LSR - Zero Page,X  
56,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	31 db			# xorl   %ebx,%ebx
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	8d 76 06		# leal   0x6(%esi),%esi
	8a 9f [L]		# movb   RAM(%edi),%bl
	d0 eb			# shrb   %bl
	19 ed			# sbbl   %ebp,%ebp
	88 9f [L]		# movb   %bl,RAM(%edi)
	89 df			# movl   %ebx,%edi
	/
# 57 - (bad)   
# 58 - CLI
58,1:
	83 c6 02		# addl   $0x2,%esi
	80 25 [F] fb		# andb   $0xfb,F
	/
# 59 - EOR - Absolute,Y   
59,3:
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	8d ba [W+1] 00 00	# leal   ADDR(%edx),%edi
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	38 d3			# cmpb   %dl,%bl
	83 d6 04		# adcl   $0x4,%esi
	8b 3c bd [M]		# movl   MAPPER(,%edi,4),%edi
	32 04 1f		# xorb   (%edi,%ebx,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 5A - (bad)   
# 5B - (bad)   
# 5C - (bad)   
# 5D - EOR - Absolute,X   
5D,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	8d b9 [W+1] 00 00	# leal   ADDR(%ecx),%edi
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	38 cb			# cmpb   %cl,%bl
	83 d6 04		# adcl   $0x4,%esi
	8b 3c bd [M]		# movl   MAPTABLE(,%edi,4),%edi
	32 04 1f		# xorb   (%edi,%ebx,1),%al
	0f be f8		# movsbl %al,%edi
	/
# 5E - LSR - Absolute,X   
5E,3:
# Warning- Doesn't check mapper
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	31 db			# xorl   %ebx,%ebx
	8a 99 [A+1]		# movb   RAM(%ecx),%bl
	d0 eb			# shrb   %bl
	8d 76 07		# leal   0x7(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	88 99 [A+1]		# movb   %bl,RAM(%ecx)
	89 df			# movl   %ebx,%edi
	/
# 5F - (bad)   
# 60 - RTS
60,1:
	31 db			# xorl   %ebx,%ebx
	50			# pushl  %eax
	8a 1d [S]		# movb   STACKPTR,%bl
	31 c0			# xorl   %eax,%eax
	fe c3			# incb   %bl
	8a 83 [T]		# movb   STACK(%ebx),%al
	fe c3			# incb   %bl
	88 1d [S]		# movb   %bl,STACKPTR
	8a a3 [T]		# movb   STACK(%ebx),%ah
	8d 76 06		# leal   0x6(%esi),%esi
	8d 58 01		# leal   0x1(%eax),%ebx
	58			# popl   %eax
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
        e9 [U]			# jmp    U
	[!]			#  end of function; stop translating
        /
# 61 - ADC - (Indirect,X)
61,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	0f b7 bf [L]		# movzwl [L](%edi),%edi
	89 fb			# movl   %edi,%ebx

# FIXME - trap I/O
 81 fb 00 60 00 00 # cmpl   $0x6000,%ebx
 73 09             # jae    +9
 81 fb 00 20 00 00 # cmpl   $0x2000,%ebx
 72 01             # jb     +1
 [^]               # int3   

	c1 ef 0c		# shrl   $0xc,%edi
	83 c5 ff		# addl   $0xffffffff,%ebp
	8b 3c bd [M]		# movl   [M](,%edi,4),%edi
	0f be c0		# movsbl %al,%eax
	0f be 1c 1f		# movsbl (%edi,%ebx,1),%ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 06		# leal   0x6(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,[V]
	0f be f8		# movsbl %al,%edi
	/
# 62 - (bad)
# 63 - (bad)
# 64 - (bad)
# 65 - ADC - Zero Page
65,2:
	0f be c0		# movsbl %al,%eax
	0f be 1d [Z+1]		# movsbl ZP,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	11 d8			# adcl   %ebx,%eax
	8d 76 03		# leal   3(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# 66 - ROR - Zero Page
66,2:
	31 db			# xorl   %ebx,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	8a 1d [Z+1]		# movb   ZP,%bl
	d0 db			# rcrb   %bl
	8d 76 05		# leal   5(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	88 1d [Z+1]		# movb   %bl,ZP
	0f be fb		# movsbl %bl,%edi
	/
# 67 - (bad)
# 68 - PLA
68,1:
	31 c0			# xorl   %eax,%eax
	a0 [S]			# movb   STACKPTR,%al
	fe c0			# incb   %al
	8d 76 04		# leal   0x4(%esi),%esi
	a2 [S]			# movb   %al,STACKPTR
	8a 80 [T]		# movb   STACK(%eax),%al
	0f be f8		# movsbl %al,%edi
	/
# 69 - ADC - Immediate
69,2:
	83 c5 ff		# addl   $0xffffffff,%ebp
	0f be c0		# movsbl %al,%eax
	83 d0 [B+1]		# adcl   $B+1,%eax
	8d 76 02		# leal   0x2(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# 6A - ROR - Accumulator
6A,1:
	83 c5 ff		# addl   $0xffffffff,%ebp
	d0 d8			# rcrb   %al
	8d 76 02		# leal   0x2(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	0f be f8		# movsbl %al,%edi
	/
# 6B - (bad)
# 6C - JMP - Indirect
6C,3:
	8b 1d [X+1]		# movl   [X+1],%ebx
	83 c6 05		# addl   $0x5,%esi
	8b 9b [W+1] 00 00	# movl   ADDR(%ebx),%ebx
	81 e3 ff ff 00 00	# andl   $0xffff,%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    UPDATE/COMPILE
	[!]
	/
# 6D - ADC - Absolute
6D,3:
	8b 1d [X+1]		# movl   XMAPADDR,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	0f be c0		# movsbl %al,%eax
	0f be 9b [W+1] 00 00	# movsbl ADDR(%ebx),%ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 04		# leal   0x4(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# 6E - ROR - Absolute
#warning - assumes ram target, doesn't check mapper
6E,3:
	83 c5 ff		# addl   $0xffffffff,%ebp
	d0 1d [A+1]		# rcrb   ADDR
	8d 76 06		# leal   6(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	0f be 3d [A+1]		# movsbl ADDR,%edi
	/
# 6F - (bad)
# 70 - BVS
70,2:
	83 c6 [>+1] 03		# addl   $3+,%esi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	8b 1d [V]		# movl   [V],%ebx
	81 c3 80 00 00 00	# addl   $0x80,%ebx
	f7 c3 00 ff ff ff	# testl  $0xffffff00,%ebx
	bb [R+1]		# movl   $[R+1],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 85 [U]		# jne    U
	83 ee [>+1] 01		# subl   $1+,%esi
	/
# 71 - ADC - (Indirect),Y
71,2:
	31 db			# xorl   %ebx,%ebx
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	66 8b 1d [Z+1]		# movw   ZP,%bx
	01 d3			# addl   %edx,%ebx

# FIXME - trap I/O
 8d bb 00 e0 ff ff	# leal   0xffffe000(%ebx),%edi
 81 ff 00 40 00 00	# cmpl   $0x4000,%edi
 73 01			# jae    +1
 [^]			# int3

	89 df			# movl   %ebx,%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx
	0f be c0		# movsbl %al,%eax
	0f be 1c 3b		# movsbl (%ebx,%edi,1),%ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 05		# leal   0x5(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,V
	0f be f8		# movsbl %al,%edi
	/
# 72 - (bad)
# 73 - (bad)
# 74 - (bad)
# 75 - ADC - Zero Page,X
75,2:
	8d 59 [B+1]		# leal   operand(%ecx),%ebx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	0f be c0		# movsbl %al,%eax
	0f be 9b [L]		# movsbl RAM(%ebx),%ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 04		# leal   0x4(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# 76 - ROR - Zero Page,X
76,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	31 db			# xorl   %ebx,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	8a 9f [L]		# movb   RAM(%edi),%bl
	d0 db			# rcrb   %bl
	8d 76 06		# leal   0x6(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	88 9f [L]		# movb   %bl,RAM(%edi)
	0f be fb		# movsbl %bl,%edi
	/
# 77 - (bad)
# 78 - SEI
78,1:
	83 c6 02		# addl   $0x2,%esi
	83 0d [F] 04		# or     $0x4,F
	/

# 79 - ADC - Absolute,Y
79,3: # FIXME - cycle count
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	8d ba [W+1] 00 00	# leal   addr(%edx),%edi
	8d 9a [W+1] 00 00	# leal   addr(%edx),%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	83 c5 ff		# addl   $0xffffffff,%ebp
	8b 3c bd [M]		# movl   MAPTABLE(,%edi,4),%edi
	0f be c0		# movsbl %al,%eax
	0f be 1c 1f		# movsbl (%edi,%ebx,1),%ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 04		# leal   0x4(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# 7A - (bad)
# 7B - (bad)
# 7C - (bad)
# 7D - ADC - Absolute,X
7D,3: # FIXME - cycle count
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	8d b9 [W+1] 00 00	# leal   addr(%ecx),%edi
	8d 99 [W+1] 00 00	# leal   addr(%ecx),%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	83 c5 ff		# addl   $0xffffffff,%ebp
	8b 3c bd [M]		# movl   MAPTABLE(,%edi,4),%edi
	0f be c0		# movsbl %al,%eax
	0f be 1c 1f		# movsbl (%edi,%ebx,1),%ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 04		# leal   0x4(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# 7E - ROR - Absolute,X
7E,3:
#warning - assumes ram target, no mapper
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c5 ff		# addl   $0xffffffff,%ebp
	d0 99 [A+1]		# rcrb   ADDR(%ecx)
	8d 76 07		# leal   7(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	0f be b9 [A+1]		# movsbl ADDR(%ecx),%edi
	/
# 7F - (bad)
# 80 - (bad)   
# 81 - STA - (Indirect,X)
81,2:
        8d 59 [B+1]             # leal   [B+1](%ecx),%ebx
        81 e3 ff 00 00 00       # andl   $0xff,%ebx
        83 c6 06                # addl   $0x6,%esi
        0f b7 9b [L]            # movzwl [L](%ebx),%ebx
        f7 c3 00 80 00 00       # testl  $0x8000,%ebx
        75 23                   # jne    +35
        81 eb 00 20 00 00       # subl   $0x2000,%ebx
        81 fb 00 40 00 00       # cmpl   $0x4000,%ebx
        8d 9b 00 20 00 00       # leal   0x2000(%ebx),%ebx
        72 08                   # jb     +8
        88 83 [L]               # movb   %al,[L](%ebx)
        eb 0c                   # jmp    +12
        e8 [O]                  # call   OUTPUT
        eb 05                   # jmp    +5
        e8 [Y]                  # call   MAPPER
        /
# 82 - (bad)   
# 83 - (bad)   
# 84 - STY - Zero Page    
84,2:
	83 c6 03		# addl   $0x3,%esi  # cycle count +3
        88 15 [Z+1]		# movb   %dl,ADDR
	/
# 85 - STA - Zero Page    
85,2:
	83 c6 03		# addl   $0x3,%esi  # cycle count +3
        a2 [Z+1]		# movb   %al,ADDR
	/
# 86 - STX - Zero Page    
86,2:
	83 c6 03		# addl   $0x3,%esi  # cycle count +3
        88 0d [Z+1]		# movb   %cl,ADDR
	/
# 87 - (bad)   
# 88 - DEY                
88,1:
	4a			# decl   %edx
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	0f be fa		# movsbl %dl,%edi
	/
# 89 - (bad)   
# 8A - TXA                
8A,1:
	0f be c1		# movsbl %cl,%eax
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	89 c7			# movl   %eax,%edi
	/
# 8B - (bad)   
# 8C - STY - Absolute     
8C,3:
	83 c6 04		# addl   $0x4,%esi  # cycle count +4
        88 15 [A+1]		# movb   %dl,ADDR
	/
# 8D - STA - Absolute     
8D,3:
	83 c6 04		# addl   $0x4,%esi  # cycle count +4
        a2 [A+1]		# movb   %al,ADDR
	/
# 8E - STX - Absolute     
8E,3:
	83 c6 04		# addl   $0x4,%esi  # cycle count +4
        88 0d [A+1]		# movb   %cl,ADDR
	/

# 8F - (bad)   
# 90 - BCC                
90,2:
	83 c6 [>+1] 03		# addl   $3+,%esi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	85 ed			# testl  %ebp,%ebp
	bb [R+1]		# movl   $[R+1],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 84 [U]		# je     U
	83 ee [>+1] 01		# subl   $1+,%esi
	/
# 91 - STA - (Indirect),Y 
91,2:
	31 db			# xorl   %ebx,%ebx
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	66 8b 1d [Z+1]		# movw   [Z+1],%bx
	66 01 d3		# addw   %dx,%bx
	83 c6 06		# addl   $0x6,%esi
        81 eb 00 20 00 00       # subl   $0x2000,%ebx
        81 fb 00 40 00 00       # cmpl   $0x4000,%ebx
        72 16                   # jb     +22
        81 fb 00 60 00 00       # cmpl   $0x6000,%ebx
        8d 9b 00 20 00 00       # leal   0x2000(%ebx),%ebx
        7d 15                   # jnl    +21
        88 83 [L]               # movb   %al,[L](%ebx)
        eb 12                   # jmp    +18
        81 c3 00 20 00 00       # addl   $0x2000,%ebx
        e8 [O]                  # call   OUTPUT
        eb 05                   # jmp    +5
	e8 [Y]			# call   MAPPER
	/
# 92 - (bad)   
# 93 - (bad)   
# 94 - STY - Zero Page,X  
94,2:
	8d 59 [B+1]		# leal   operand(%ecx),%ebx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	88 93 [L]		# movb   %dl,RAM(%ebx)
	/
# 95 - STA - Zero Page,X  
95,2: 
	8d 59 [B+1]		# leal   operand(%ecx),%ebx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	88 83 [L]		# movb   %al,RAM(%ebx)
	/
# 96 - STX - Zero Page,Y  
96,2:
	8d 5a [B+1]		# leal   operand(%edx),%ebx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	88 8b [L]		# movb   %cl,RAM(%ebx)
	/
# 97 - (bad)   
# 98 - TYA                
98,1:
	0f be c2		# movsbl %dl,%eax
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	89 c7			# movl   %eax,%edi
	/
# 99 - STA - Absolute,Y   
99,3:
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	83 c6 05		# addl   $5,%esi    # cycle count +5
	88 82 [A+1]		# movb   %al,[A+1](%edx)
	/
# 9A - TXS
9A,1:
	88 0d [S]		# movb   %cl,S
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	/                
# 9B - (bad)   
# 9C - (bad)   
# 9D - STA - Absolute,X   
9D,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c6 05		# addl   $5,%esi    # cycle count +5
	88 81 [A+1]		# movb   %al,[A+1](%ecx)
	/
# 9E - (bad)   
# 9F - (bad)   
# A0 - LDY - Immediate
a0,2:
	31 d2			# xorl   %edx,%edx
	83 c6 02		# addl   $0x2,%esi
	b2 [B+1]		# movb   $[B+1],%dl
	bf [E+1]		# movl   $[E+1],%edi
	/
# A1 - LDA - (Indirect,X)
#   # has wraparound bug (FF->100) but it probably doesn't matter
A1,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	31 db			# xorl   %ebx,%ebx
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	66 8b 9f [L]		# movw   RAM(%edi),%bx
	89 df			# movl   %ebx,%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	8d 76 06		# leal   0x6(%esi),%esi
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx

# FIXME - trap I/O
 81 fb 00 60 00 00 # cmpl   $0x6000,%ebx
 73 09             # jae    +9
 81 fb 00 20 00 00 # cmpl   $0x2000,%ebx
 72 01             # jb     +1
 [^]               # int3   

	0f be 04 1f		# movsbl (%edi,%ebx,1),%eax
	89 c7			# movl   %eax,%edi
	/
# A2 - LDX - Immediate
a2,2:
	31 c9			# xorl   %ecx,%ecx
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	b1 [B+1]		# movb   $[B+1],%cl
	bf [E+1]		# movl   $[E+1],%edi
	/
# A3 - (bad)
# A4 - LDY - Zero Page
A4,2:
	31 d2			# xorl   %edx,%edx
	83 c6 03		# addl   $0x3,%esi  # cycle count +3
	8a 15 [Z+1]		# movb   ZPADDR,%dl
	0f be fa		# movsbl %dl,%edi
	/
# A5 - LDA - Zero Page
A5,2:
	0f be 05 [Z+1]		# movsbl ZPADDR,%eax
	83 c6 03		# addl   $0x3,%esi  # cycle count +3
	89 c7			# movl   %eax,%edi
	/
# A6 - LDX - Zero Page
A6,2:
	31 c9			# xorl   %ecx,%ecx
	bf 80 ff ff ff 		# movl   $0xffffff80,%edi
	8a 0d [Z+1]		# movb   ZP,%cl
	83 c6 03		# addl   $0x3,%esi  # cycle count +3
	01 cf			# addl   %ecx,%edi
	83 f7 80		# xorl   $0xffffff80,%edi
	/
# A7 - (bad)
# A8 - TAY
A8,1:
	89 c2			# movl   %eax,%edx
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	0f be fa		# movsbl %dl,%edi
	/
# A9 - LDA - Immediate
A9,2:
	b8 [E+1]		# movl   $[E+1],%eax
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	bf [E+1]		# movl   $[E+1],%edi
	/
# AA - TAX
AA,1:
	89 c1			# movl   %eax,%ecx
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	0f be f9		# movsbl %cl,%edi
	/
# AB - (bad)
# AC - LDY - Absolute
AC,3:
	8b 1d [X+1]		# movl   XMAP,%ebx
	83 c6 04		# addl   $0x4,%esi
	0f be 93 [W+1] 00 00	# movsbl RAM(%ebx),%edx
	89 d7			# movl   %edx,%edi
	/
# AD - LDA - Absolute
AD,3:
        8b 1d [X+1]		# movl   XMAP,%ebx
	83 c6 04		# addl   $0x4,%esi
	0f be 83 [W+1] 00 00	# movsbl 0x0000AAAA(%ebx),%eax
        89 c7			# movl   %eax,%edi
	/
# AE - LDX - Absolute
AE,3:
	8b 1d [X+1]		# movl   XMAP,%ebx
	83 c6 04		# addl   $0x4,%esi
	0f be 8b [W+1] 00 00	# movsbl 0x0000AAAA(%ebx),%ecx
	89 cf			# movl   %ecx,%edi
	/
# AF - (bad)
# B0 - BCS
B0,2:
	83 c6 [>+1] 03		# addl   $3+,%esi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	85 ed			# testl  %ebp,%ebp
	bb [R+1]		# movl   $[R+1],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 85 [U]		# jne    U
	83 ee [>+1] 01		# subl   $1+,%esi
	/
# B1 - LDA - (Indirect),Y
B1,2:
	31 db			# xorl   %ebx,%ebx
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	66 8b 1d [Z+1]		# movw   ZP,%bx
	01 d3			# addl   %edx,%ebx
	8d 76 05		# leal   0x5(%esi),%esi
	89 df			# movl   %ebx,%edi
	c1 ef 0c		# shrl   $0xc,%edi
	8d 83 00 e0 ff ff       # leal   0xffffe000(%ebx),%eax
	8b 3c bd [M]		# movl   MAPTABLE(,%edi,4),%edi
	3d 00 40 00 00          # cmpl   $0x4000,%eax
	73 07                   # jae    +7
	e8 [I]                  # call   [I]
	eb 04                   # jmp    +4
	0f be 3c 1f             # movsbl (%edi,%ebx,1),%edi
	89 f8                   # movl   %edi,%eax
	/
# B2 - (bad)
# B3 - (bad)
# B4 - LDY - Zero Page,X
B4,2:
	8d 59 [B+1]		# leal   [B+1](%ecx),%ebx
	31 d2			# xorl   %edx,%edx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	8a 93 [L]		# movb   RAM(%ebx),%dl
	0f be fa		# movsbl %dl,%edi
	/
# B5 - LDA - Zero Page,X
B5,2:
	8d 41 [B+1]		# leal   operand(%ecx),%eax
	25 ff 00 00 00		# andl   $0xff,%eax
	8d 76 04		# leal   0x4(%esi),%esi
	0f be 80 [L]		# movsbl RAM(%eax),%eax
	89 c7			# movl   %eax,%edi
	/
# B6 - LDX - Zero Page,Y
B6,2:
	8d 5a [B+1]		# leal   [B+1](%edx),%ebx
	31 c9			# xorl   %ecx,%ecx
	81 e3 ff 00 00 00	# andl   $0xff,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	8a 8b [L]		# movb   RAM(%ebx),%cl
	0f be f9		# movsbl %cl,%edi
	/
# B7 - (bad)
# B8 - CLV
B8,1:
	83 c6 02		# addl   $0x2,%esi
	c7 05 [V] 00 00 00 00	# movl   $0x0,[V]
	/
# B9 - LDA - Absolute,Y
B9,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	8d 82 [W+1] 00 00	# leal   ADDR(%edx),%eax
	c1 e8 0c		# shrl   $0xc,%eax
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	8b 3c 85 [M]		# movl   MAPTABLE(,%eax,4),%edi
	83 c6 04		# addl   $0x4,%esi
	0f be 04 1f		# movsbl (%edi,%ebx,1),%eax
	89 c7			# movl   %eax,%edi
	/
# BA - TSX
BA,1:
	31 c9			# xorl   %ecx,%ecx
	83 c6 02		# addl   $0x2,%esi
	8a 0d [S]		# movb   [S],%cl
	0f be f9		# movsbl %cl,%edi
	/
# BB - (bad)
# BC - LDY - Absolute,X
BC,3: 
# FIXME - cycle count wrong
	81 e1 ff 00 00 00       # andl   $0xff,%ecx
	8d 91 [W+1] 00 00	# leal   ADDR(%ecx),%edx
	c1 ea 0c		# shrl   $0xc,%edx
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	8b 3c 95 [M]		# movl   MAPTABLE(,%edx,4),%edi
	83 c6 04		# addl   $0x4,%esi
	0f be 14 1f		# movsbl (%edi,%ebx,1),%edx
	89 d7			# movl   %edx,%edi
	/
# BD - LDA - Absolute,X
BD,3:
# FIXME - cycle count wrong
        81 e1 ff 00 00 00	# andl   $0xff,%ecx
	8d 81 [W+1] 00 00	# leal   ADDR(%ecx),%eax
	c1 e8 0c		# shrl   $0xc,%eax
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	8b 3c 85 [M]		# movl   MAPTABLE(,%eax,4),%edi
	83 c6 04		# addl   $0x4,%esi
	0f be 04 1f		# movsbl (%edi,%ebx,1),%eax
	89 c7			# movl   %eax,%edi
	/
# BE - LDX - Absolute,Y
BE,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	8d 8a [W+1] 00 00	# leal   ADDR(%edx),%ecx
	c1 e9 0c		# shrl   $0xc,%ecx
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	8b 3c 8d [M]		# movl   MAPTABLE(,%ecx,4),%edi
	83 c6 04		# addl   $0x4,%esi
	0f be 0c 1f		# movsbl (%edi,%ebx,1),%ecx
	89 cf			# movl   %ecx,%edi
	/
# BF - (bad)
# C0 - CPY - Immediate    
C0,2:
	0f b6 da		# movzbl %dl,%ebx
	bd 01 00 00 00		# movl   $0x1,%ebp
	81 eb [B+1] 00 00 00	# subl   $[B+1],%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	8d 76 02                # leal   0x2(%esi),%esi  # cycle count +2
	/
# C1 - CMP - (Indirect,X) 
C1,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	31 db			# xorl   %ebx,%ebx
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	25 ff 00 00 00		# andl   $0xff,%eax
	66 8b 9f [L]		# movw   [L](%edi),%bx

# FIXME - trap I/O
 8d bb 00 e0 ff ff	# leal   0xffffe000(%ebx),%edi
 81 ff 00 40 00 00	# cmpl   $0x4000,%edi
 73 01			# jae    +1
 [^]			# int3

	89 df			# movl   %ebx,%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	8d 76 06		# leal   0x6(%esi),%esi
	8b 2c 9d [M]		# movl   [M](,%ebx,4),%ebp
	89 c3			# movl   %eax,%ebx
	0f b6 3c 2f		# movzbl (%edi,%ebp,1),%edi
	bd 01 00 00 00		# movl   $0x1,%ebp
	29 fb			# subl   %edi,%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# C2 - (bad)   
# C3 - (bad)   
# C4 - CPY - Zero Page    
C4,2:
	0f b6 da		# movzbl %dl,%ebx
	0f b6 3d [Z+1]		# movzbl ZP,%edi
	bd 01 00 00 00		# movl   $0x1,%ebp
	29 fb			# subl   %edi,%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	8d 76 03		# leal   0x3(%esi),%esi  # cycle count +3
	/
# C5 - CMP - Zero Page    
C5,2:
	31 db			# xorl   %ebx,%ebx
	0f b6 3d [Z+1]		# movzbl ZP,%edi
	88 c3			# movb   %al,%bl
	bd 01 00 00 00		# movl   $0x1,%ebp
	29 fb			# subl   %edi,%ebx
	8d 76 03		# leal   0x3(%esi),%esi  # cycle count +3
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# C6 - DEC - Zero Page    
C6,2:
	31 db			# xorl   %ebx,%ebx
	8a 1d [Z+1]		# movb   ZP,%bl
	80 eb 81		# subb   $0x81,%bl
	83 c6 05		# addl   $0x5,%esi  # cycle count +5
	81 eb 80 00 00 00	# subl   $0x80,%ebx
	89 df			# movl   %ebx,%edi
	88 1d [Z+1]		# movb   %bl,ZP
	/
# C7 - (bad)   
# C8 - INY                
C8,1:
	42			# incl   %edx
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	0f be fa		# movsbl %dl,%edi
	/
# C9 - CMP - Immediate    
C9,2:
	bd 01 00 00 00		# movl   $1,%ebp
	0f b6 d8		# movzbl %al,%ebx
	83 c6 02		# addl   $2,%esi  # cycle count +2
	81 eb [B+1] 00 00 00	# subl   $[B+1],%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0,%ebp
	/
# CA - DEX
CA,1:
	49			# decl   %ecx
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	0f be f9		# movsbl %cl,%edi
	/
# CB - (bad)   
# CC - CPY - Absolute     
CC,3:
	8b 3d [X+1]		# movl   X,%edi
	31 db			# xorl   %ebx,%ebx
	bd 01 00 00 00		# movl   $0x1,%ebp
	88 d3			# movb   %dl,%bl
	0f b6 bf [W+1] 00 00	# movzbl ADDR(%edi),%edi
	29 fb			# subl   %edi,%ebx
	8d 76 04		# leal   4(%esi),%esi
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# CD - CMP - Absolute     
CD,3:
	8b 3d [X+1]		# movl   X,%edi
	31 db			# xorl   %ebx,%ebx
	bd 01 00 00 00		# movl   $0x1,%ebp
	88 c3			# movb   %al,%bl
	0f b6 bf [W+1] 00 00	# movzbl ADDR(%edi),%edi
	29 fb			# subl   %edi,%ebx
	8d 76 04		# leal   4(%esi),%esi
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# CE - DEC - Absolute     
CE,3:
	31 db			# xorl   %ebx,%ebx
	8a 1d [A+1]		# movb   ADDR,%bl
	80 eb 81		# subb   $0x81,%bl
	83 c6 06		# addl   $0x6,%esi  # cycle count +6
	81 eb 80 00 00 00	# subl   $0x80,%ebx
	89 df			# movl   %ebx,%edi
	88 1d [A+1]		# movb   %bl,ADDR
	/
# CF - (bad)   
# D0 - BNE                
D0,2:
	83 c6 [>+1] 03		# addl   $3+,%esi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	f7 c7 ff 00 00 00	# testl  $0xff,%edi
	bb [R+1]		# movl   $[R+1],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 85 [U]		# jne    U
	83 ee [>+1] 01		# subl   $1+,%esi
	/
# D1 - CMP   (Indirect),Y 
D1,2:
	31 db			# xorl   %ebx,%ebx
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	66 8b 1d [Z+1]		# movw   [Z+1],%bx
	25 ff 00 00 00		# andl   $0xff,%eax
	01 d3			# addl   %edx,%ebx

# FIXME - trap I/O
 8d bb 00 e0 ff ff	# leal   0xffffe000(%ebx),%edi
 81 ff 00 40 00 00	# cmpl   $0x4000,%edi
 73 01			# jae    +1
 [^]			# int3

	89 df			# movl   %ebx,%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	8d 76 05		# leal   0x5(%esi),%esi
	8b 2c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebp
	89 c3			# movl   %eax,%ebx
	0f b6 3c 2f		# movzbl (%edi,%ebp,1),%edi
	bd 01 00 00 00		# movl   $0x1,%ebp
	29 fb			# subl   %edi,%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# D2 - (bad)   
# D3 - (bad)   
# D4 - (bad)   
# D5 - CMP - Zero Page,X  
D5,2:
	8d 69 [B+1]		# leal   [B+1](%ecx),%ebp
	31 db			# xorl   %ebx,%ebx
	81 e5 ff 00 00 00	# andl   $0xff,%ebp
	88 c3			# movb   %al,%bl
	8d 76 04		# leal   0x4(%esi),%esi
	0f b6 bd [L]		# movzbl RAM(%ebp),%edi
	29 fb			# subl   %edi,%ebx
	bd 01 00 00 00		# movl   $0x1,%ebp
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# D6 - DEC - Zero Page,X  
D6,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	31 db			# xorl   %ebx,%ebx
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	8a 9f [L]		# movb   RAM(%edi),%bl
	80 eb 81		# subb   $0x81,%bl
	83 c6 06		# addl   $0x6,%esi
	81 eb 80 00 00 00	# subl   $0x80,%ebx
	88 9f [L]		# movb   %bl,RAM(%edi)
	89 df			# movl   %ebx,%edi
	/
# D7 - (bad)   
# D8 - CLD
D8,1:
	83 c6 02		# addl   $0x2,%esi
	80 25 [F] f7		# andb   $0xf7,[F]
	/
# D9 - CMP - Absolute,Y   
D9,3:
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	25 ff 00 00 00		# andl   $0xff,%eax
	8d 9a [W+1] 00 00	# leal   [W+1](%edx),%ebx
	89 df			# movl   %ebx,%edi
	38 d3			# cmpb   %dl,%bl
	83 d6 04		# adcl   $0x4,%esi
	c1 eb 0c		# shrl   $0xc,%ebx
	8b 2c 9d [M]		# movl   [M](,%ebx,4),%ebp
	89 c3			# movl   %eax,%ebx
	0f b6 3c 2f		# movzbl (%edi,%ebp,1),%edi
	bd 01 00 00 00		# movl   $0x1,%ebp
	29 fb			# subl   %edi,%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# DA - (bad)   
# DB - (bad)   
# DC - (bad)   
# DD - CMP - Absolute,X
DD,3:
# FIXME - cycle count wrong
	bd [W+1] 00 00		# movl   $ADDR,%ebp
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	01 cd			# addl   %ecx,%ebp
	31 db			# xorl   %ebx,%ebx
	c1 ed 0c		# shrl   $0xc,%ebp
	88 c3			# movb   %al,%bl
	8b 2c ad [M]		# movl   MAPTABLE(,%ebp,4),%ebp
	8d 76 04		# leal   0x4(%esi),%esi
	0f b6 bc 29 [W+1] 00 00	# movzbl ADDR(%ecx,%ebp,1),%edi
	bd 01 00 00 00		# movl   $0x1,%ebp
	29 fb			# subl   %edi,%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# DE - DEC - Absolute,X   
DE,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	31 db			# xorl   %ebx,%ebx
	8a 99 [A+1]		# movb   ADDR(%ecx),%bl
	80 eb 81		# subb   $0x81,%bl
	83 c6 07		# addl   $0x7,%esi  # cycle count +7
	81 eb 80 00 00 00	# subl   $0x80,%ebx
	89 df			# movl   %ebx,%edi
	88 99 [A+1]		# movb   %bl,ADDR(%ecx)
	/
# DF - (bad)   
# E0 - CPX - Immediate
E0,2:
	0f b6 d9		# movzbl %cl,%ebx
	bd 01 00 00 00		# movl   $0x1,%ebp
	81 eb [B+1] 00 00 00	# subl   $[B+1],%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	8d 76 02		# leal   0x2(%esi),%esi  # cycle count +2
	/
# E1 - SBC - (Indirect,X)
# E2 - (bad)
# E3 - (bad)
# E4 - CPX - Zero Page
E4,2:
	0f b6 d9		# movzbl %cl,%ebx
	0f b6 3d [Z+1]		# movzbl [Z+1],%edi
	bd 01 00 00 00		# movl   $0x1,%ebp
	29 fb			# subl   %edi,%ebx
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	8d 76 03		# leal   0x3(%esi),%esi  # cycle count +3
	/
# E5 - SBC - Zero Page
E5,2:
	0f be 1d [Z+1]		# movsbl [Z+1],%ebx
	0f be c0		# movsbl %al,%eax
	83 f3 ff		# xorl   $0xffffffff,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	11 d8			# adcl   %ebx,%eax
	8d 76 03		# leal   0x3(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# E6 - INC - Zero Page
E6,2:
	31 db			# xorl   %ebx,%ebx
	8a 1d [Z+1]		# movb   ZP,%bl
	80 c3 81		# addb   $0x81,%bl
	83 c6 05		# addl   $0x5,%esi  # cycle count +5
	81 eb 80 00 00 00	# subl   $0x80,%ebx
	89 df			# movl   %ebx,%edi
	88 1d [Z+1]		# movb   %bl,ZP
	/
# E7 - (bad)
# E8 - INX
E8,1:
	41			# incl   %ecx
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	0f be f9		# movsbl %cl,%edi
	/
# E9 - SBC - Immediate
E9,2:
	83 c5 ff		# addl   $0xffffffff,%ebp
	0f be c0		# movsbl %al,%eax
	83 d0 [C+1]		# adcl   $[C+1],%eax
	8d 76 02		# leal   0x2(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
#alternatively, could do: subl $0x1,%ebp
#                         sbbl $imm,%eax
# but then the carry flag must be inverted again before putting into ebp,
# so it's easier to invert the immediate value
	/
# EA - NOP
EA,1:
	83 c6 02		# addl   $0x2,%esi  # cycle count +2
	/
# EB - (bad)
# EC - CPX - Absolute
EC,3:
	8b 3d [X+1]		# movl   XLATADDR,%edi
	31 db			# xorl   %ebx,%ebx
	bd 01 00 00 00		# movl   $0x1,%ebp
	88 cb			# movb   %cl,%bl
	0f b6 bf [W+1] 00 00	# movzbl ADDR(%edi),%edi
	29 fb			# subl   %edi,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	0f be fb		# movsbl %bl,%edi
	83 dd 00		# sbbl   $0x0,%ebp
	/
# ED - SBC - Absolute
ED,3:
	8b 3d [X+1]		# movl   XMAPADDR,%edi
	25 ff 00 00 00		# andl   $0xff,%eax
	31 db			# xorl   %ebx,%ebx
	83 c0 80		# addl   $0xffffff80,%eax
	8a 9f [W+1] 00 00	# movb   ADDR(%edi),%bl
	83 f0 80		# xorl   $0xffffff80,%eax
	83 c3 80		# addl   $0xffffff80,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	83 f3 7f		# xorl   $0x7f,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	11 d8			# adcl   %ebx,%eax
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# EE - INC - Absolute
EE,3:
	31 db			# xorl   %ebx,%ebx
	8a 1d [A+1]		# movb   ADDR,%bl
	80 c3 81		# addb   $0x81,%bl
	83 c6 06		# addl   $0x6,%esi  # cycle count +6
	81 eb 80 00 00 00	# subl   $0x80,%ebx
	89 df			# movl   %ebx,%edi
	88 1d [A+1]		# movb   %bl,ADDR
	/
# EF - (bad)
# F0 - BEQ
F0,2:
	83 c6 [>+1] 03		# addl   $3+,%esi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	f7 c7 ff 00 00 00	# testl  $0xff,%edi
	bb [R+1]		# movl   $[R+1],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 84 [U]		# je     U
	83 ee [>+1] 01		# subl   $1+,%esi
	/
# F1 - SBC - (Indirect),Y
f1,2:
	31 db			# xorl   %ebx,%ebx
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	66 8b 1d [Z+1]		# movw   ZP,%bx
	01 d3			# addl   %edx,%ebx

# FIXME - trap I/O
 8d bb 00 e0 ff ff	# leal   0xffffe000(%ebx),%edi
 81 ff 00 40 00 00	# cmpl   $0x4000,%edi
 73 01			# jae    +1
 [^]			# int3

	89 df			# movl   %ebx,%edi
	c1 eb 0c		# shrl   $0xc,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	8b 1c 9d [M]		# movl   MAPTABLE(,%ebx,4),%ebx
	0f be c0		# movsbl %al,%eax
	0f be 1c 3b		# movsbl (%ebx,%edi,1),%ebx
	f7 d3			# notl   %ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 05		# leal   0x5(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,V
	0f be f8		# movsbl %al,%edi
	/
# F2 - (bad)
# F3 - (bad)
# F4 - (bad)
# F5 - SBC - Zero Page,X
F5,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	25 ff 00 00 00		# andl   $0xff,%eax
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	31 db			# xorl   %ebx,%ebx
	83 c0 80		# addl   $0xffffff80,%eax
	8a 9f [L]		# movb   RAM(%edi),%bl
	83 f0 80		# xorl   $0xffffff80,%eax
	83 c3 80		# addl   $0xffffff80,%ebx
	8d 76 04		# leal   0x4(%esi),%esi
	83 f3 7f		# xorl   $0x7f,%ebx
	83 c5 ff		# addl   $0xffffffff,%ebp
	11 d8			# adcl   %ebx,%eax
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# F6 - INC - Zero Page,X
F6,2:
	8d 79 [B+1]		# leal   [B+1](%ecx),%edi
	81 e7 ff 00 00 00	# andl   $0xff,%edi
	31 db			# xorl   %ebx,%ebx
	8a 9f [L]		# movb   0x0(%edi),%bl
	80 c3 81		# addb   $0x81,%bl
	83 c6 06		# addl   $0x6,%esi
	81 eb 80 00 00 00	# subl   $0x80,%ebx
	88 9f [L]		# movb   %bl,0x0(%edi)
	89 df			# movl   %ebx,%edi
	/
# F7 - (bad)
# F8 - SED
F8,1: #What happens on a real NES when the CPU is put into decimal mode?
	83 c6 02		# addl   $0x2,%esi
	83 0d [F] 08		# orb    $0x8,[F]
	/
# F9 - SBC - Absolute,Y
F9,3:
# FIXME - cycle count wrong
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	25 ff 00 00 00		# andl   $0xff,%eax
	8d ba [W+1] 00 00	# leal   ADDR(%edx),%edi
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	83 c0 80		# addl   $0xffffff80,%eax
	8b 3c bd [M]		# movl   MAPTABLE(,%edi,4),%edi
	83 f0 80		# xorl   $0xffffff80,%eax
	83 c5 ff		# addl   $0xffffffff,%ebp
	0f be 1c 1f		# movsbl (%edi,%ebx,1),%ebx
	f7 d3			# notl   %ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 04		# leal   0x4(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# FA - (bad)
# FB - (bad)
# FC - (bad)
# FD - SBC - Absolute,X
FD,3:
# FIXME - cycle count wrong
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	25 ff 00 00 00		# andl   $0xff,%eax
	8d b9 [W+1] 00 00	# leal   ADDR(%ecx),%edi
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	83 c0 80		# addl   $0xffffff80,%eax
	8b 3c bd [M]		# movl   MAPTABLE(,%edi,4),%edi
	83 f0 80		# xorl   $0xffffff80,%eax
	83 c5 ff		# addl   $0xffffffff,%ebp
	0f be 1c 1f		# movsbl (%edi,%ebx,1),%ebx
	f7 d3			# notl   %ebx
	11 d8			# adcl   %ebx,%eax
	8d 76 04		# leal   0x4(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/
# FE - INC - Absolute,X
FE,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	31 db			# xorl   %ebx,%ebx
	8a 99 [A+1]		# movb   [A+1](%ecx),%bl
	80 c3 81		# addb   $0x81,%bl
	83 c6 07		# addl   $0x7,%esi
	81 eb 80 00 00 00	# subl   $0x80,%ebx
	89 df			# movl   %ebx,%edi
	88 99 [A+1]		# movb   %bl,[A+1](%ecx)
	/
# FF - (bad)

#-----------------------------------------------------------------------------
# Specific Optimizations

# movsx is slow (3 cycles on a Pentium) so we eliminate it whenever possible:

09 80/80,2: # ORA with a negative is always negative (and nonzero)
	0d [E+1]	# orl    $[E+1],%eax
	83 c6 02	# addl   $2,%esi
	bf ff ff ff ff  # movl   $0xffffffff,%edi
	/
09/BF 00/FF,2: # ORA/EOR #$00  (set flags only)
	83 c6 02	# addl   $2,%esi
	0f be f8	# movsbl %al,%edi
	/
09 FF/FF,2: # ORA #$FF  (set all bits)
	b8 ff ff ff ff  # movl   $0xffffffff,%eax
	83 c6 02	# addl   $2,%esi
	bf ff ff ff ff  # movl   $0xffffffff,%edi
	/
29 00/80,2: # AND with a positive value is always positive (sign flag=0)
	25 [E+1]	# andl   $imm,%eax
	83 c6 02	# addl   $2,%esi
	89 c7          	# movl   %eax,%edi
	/
29 00/FF,2: # AND #$00  (clear registers only)
	31 c0          	# xorl   %eax,%eax
	83 c6 02	# addl   $2,%esi
	31 ff          	# xorl   %edi,%edi
	/
29 FF/FF,2: # AND #$FF  (set flags only)
	83 c6 02	# addl   $2,%esi
	0f be f8        # movsbl %al,%edi
	/
A9 00,2: # LDA #$00  (clear registers only, same as AND #0)
	83 c6 02	# addl   $2,%esi
	31 c0          	# xorl   %eax,%eax
	31 ff          	# xorl   %edi,%edi
	/
A2 00,2: # LDX #$00  (clear registers)
	83 c6 02	# addl   $2,%esi
	31 c9           # xorl   %ecx,%ecx
	31 ff           # xorl   %edi,%edi
	/
A0 00,2: # LDY #$00  (clear registers)
	83 c6 02	# addl   $2,%esi
	31 d2           # xorl   %edx,%edx
	31 ff           # xorl   %edi,%edi
	/

# CLC followed by ADC -> ADD
18 69,3:
	0f be c0	# movsbl %al,%eax
	83 c0 [B+2]     # addl   $[B+2],%eax
	8d 76 04        # leal   0x4(%esi),%esi
	19 ed		# sbbl   %ebp,%ebp
	a3 [V]		# movl   %eax,VFLAG
	0f be f8	# movsbl %al,%edi
	/
# SEC followed by SBC -> SUB
31 E9,3:
	bd 01 00 00 00	# movl   $0x1,%ebp
	0f be c0	# movsbl %al,%eax
	83 e8 [B+2]	# subl   $[B+2],%eax
	8d 76 04	# leal   0x4(%esi),%esi
	83 dd 00        # sbbl   $0,%ebp
	a3 [V]		# movl   %eax,VFLAG
	0f be f8	# movsbl %al,%edi
	/

# Repeated NOP
EA EA,2:
	83 c6 04	# addl   $0x4,%esi  # cycle count +4
	/
EA EA EA,3:
	83 c6 06	# addl   $0x6,%esi  # cycle count +6
	/
EA EA EA EA,4:
	83 c6 08	# addl   $0x8,%esi  # cycle count +8
	/

# Repeated INX
E8 E8,2:
	83 c1 02        # addl   $0x2,%ecx
	83 c6 04	# addl   $4,%esi  # cycle count +2x2
	0f be f9	# movsbl %cl,%edi
	/
E8 E8 E8,3:
	83 c1 03        # addl   $0x3,%ecx
	83 c6 06	# addl   $6,%esi  # cycle count +2x3
	0f be f9	# movsbl %cl,%edi
	/
E8 E8 E8 E8,4:
	83 c1 04        # addl   $0x4,%ecx
	83 c6 08	# addl   $8,%esi  # cycle count +2x4
	0f be f9	# movsbl %cl,%edi
	/

# Repeated INY
C8 C8,2:
	83 c2 02        # addl   $0x2,%edx
	83 c6 04        # addl   $4,%esi  # cycle count +2x2
	0f be fa	# movsbl %dl,%edi
	/
C8 C8 C8,3:
	83 c2 03        # addl   $0x3,%edx
	83 c6 06        # addl   $6,%esi  # cycle count +3x2
	0f be fa	# movsbl %dl,%edi
	/
C8 C8 C8 C8,4:
	83 c2 04        # addl   $0x4,%edx
	83 c6 08        # addl   $8,%esi  # cycle count +4x2
	0f be fa	# movsbl %dl,%edi
	/

# Repeated DEX
CA CA,2:
	83 e9 02	# subl   $0x2,%ecx
	83 c6 04	# addl   $4,%esi  # cycle count +4
	0f be f9	# movsbl %cl,%edi
	/
CA CA CA,3:
	83 e9 03	# subl   $0x3,%ecx
	83 c6 06	# addl   $6,%esi  # cycle count +6
	0f be f9	# movsbl %cl,%edi
	/
CA CA CA CA,4:
	83 e9 04	# subl   $0x4,%ecx
	83 c6 08	# addl   $8,%esi  # cycle count +8
	0f be f9	# movsbl %cl,%edi
	/

# Repeated DEY
88 88,2:
	83 ea 02        # subl   $0x2,%edx
	83 c6 04	# addl   $4,%esi  # cycle count +4
	0f be fa        # movsbl %dl,%edi
	/
88 88 88,3:
	83 ea 03        # subl   $0x3,%edx
	83 c6 06	# addl   $6,%esi  # cycle count +6
	0f be fa        # movsbl %dl,%edi
	/
88 88 88 88,4:
	83 ea 04        # subl   $0x4,%edx
	83 c6 08	# addl   $8,%esi  # cycle count +8
	0f be fa        # movsbl %dl,%edi
	/

# Repeated ASL
0A 0A,2:
	c0 e0 02	# shlb   $0x2,%al
	8d 76 04	# leal   0x4(%esi),%esi  # cycle count +4
        19 ed		# sbbl   %ebp,%ebp
	0f be f8	# movsbl %al,%edi
	/
0A 0A 0A,3:
	c0 e0 03	# shlb   $0x3,%al
	8d 76 06	# leal   0x6(%esi),%esi  # cycle count +6
        19 ed		# sbbl   %ebp,%ebp
	0f be f8	# movsbl %al,%edi
	/
0A 0A 0A 0A,4:
	c0 e0 04	# shlb   $0x4,%al
	8d 76 08	# leal   0x8(%esi),%esi  # cycle count +8
        19 ed		# sbbl   %ebp,%ebp
	0f be f8	# movsbl %al,%edi
	/

# Repeated LSR
4A 4A,2:
	25 ff 00 00 00	# andl   $0xff,%eax
	c1 e8 02	# shrl   $0x2,%eax
	8d 76 04	# leal   0x4(%esi),%esi
	19 ed		# sbbl   %ebp,%ebp
	89 c7		# movl   %eax,%edi
	/
4A 4A 4A,3:
	25 ff 00 00 00	# andl   $0xff,%eax
	c1 e8 03	# shrl   $0x3,%eax
	8d 76 06	# leal   0x6(%esi),%esi
	19 ed		# sbbl   %ebp,%ebp
	89 c7		# movl   %eax,%edi
	/
4A 4A 4A 4A,4:
	25 ff 00 00 00	# andl   $0xff,%eax
	c1 e8 04	# shrl   $0x4,%eax
	8d 76 08	# leal   0x8(%esi),%esi
	19 ed		# sbbl   %ebp,%ebp
	89 c7		# movl   %eax,%edi
	/


# Predictable branches.  Sometimes a 'conditional' branch is in fact always
# taken.  It is good to recognize these cases, because the branch may be
# followed by non-executable data, which we don't want to try to translate.

# LDA of non-zero followed by BNE is always taken
A9 00/00 D0,4:
	b8 [E+1]		# movl   $[E+1],%eax
	83 c6 [>+3] 05		# addl   $5+,%esi # do timing count
	bf [E+1]		# movl   $[E+1],%edi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	bb [R+3]		# movl   $[R+3],%ebx
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	[!]
	/
# LDA #0 followed by BNE is never taken (overrides previous case for LDA #0)
A9 00 D0,4:
	31 c0			# xorl   %eax,%eax
	31 ff			# xorl   %edi,%edi
	8d 76 04		# leal   4(%esi),%esi # do timing count
	/
# LDX of non-zero followed by BNE is always taken
A2 00/00 D0,4:
	b9 [E+1]		# movl   $[E+1],%ecx
	bf [E+1]		# movl   $[E+1],%edi
	83 c6 [>+3] 05		# addl   $5+,%esi # do timing count
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	bb [R+3]		# movl   $[R+3],%ebx
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	[!]
	/
# LDX #0 followed by BNE is never taken (overrides previous case for LDX #0)
A2 00 D0,4:
	31 c9			# xorl   %ecx,%ecx
	31 ff			# xorl   %edi,%edi
	8d 76 04		# leal   4(%esi),%esi # do timing count
	/

# LDY of non-zero followed by BNE is always taken
A0 00/00 D0,4:
	ba [E+1]		# movl   $[E+1],%edx
	bf [E+1]		# movl   $[E+1],%edi
	83 c6 [>+3] 05		# addl   $5+,%esi # do timing count
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	bb [R+3]		# movl   $[R+3],%ebx
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	[!]
	/
# LDY #0 followed by BNE is never taken (overrides previous case for LDY #0)
A0 00 D0,4:
	31 d2			# xorl   %edx,%edx
	31 ff			# xorl   %edi,%edi
	8d 76 04		# leal   4(%esi),%esi # do timing count
	/

# LDA #0 followed by BEQ is always taken
A9 00 F0,4:
	31 c0			# xorl   %eax,%eax
	31 ff			# xorl   %edi,%edi
	8d 76 [>+3] 05		# leal   5+(%esi),%esi # do timing count
	bb [R+3]		# movl   $[R+3],%ebx
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    UPDATE/COMPILE
	[!]
	/
# LDX #0 followed by BEQ is always taken
A2 00 F0,4:
	31 c9			# xorl   %ecx,%ecx
	31 ff			# xorl   %edi,%edi
	8d 76 [>+3] 05		# leal   5+(%esi),%esi # do timing count
	bb [R+3]		# movl   $[R+3],%ebx
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    UPDATE/COMPILE
	[!]
	/
# LDY #0 followed by BEQ is always taken
A0 00 F0,4:
	31 d2			# xorl   %edx,%edx
	31 ff			# xorl   %edi,%edi
	8d 76 [>+3] 05		# leal   5+(%esi),%esi # do timing count
	bb [R+3]		# movl   $[R+3],%ebx
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    UPDATE/COMPILE
	[!]
	/

# This shows up quite a bit also... LDA #0 / STA / BEQ 
A9 00 85 00/00 F0,6:
	31 c0			# xorl   %eax,%eax
	31 ff			# xorl   %edi,%edi
	8d 76 [>+5] 08		# leal   8+(%esi),%esi # do timing count
	a2 [Z+3]		# movb   %al,[Z+3]
	bb [R+5]		# movl   $[R+5],%ebx
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    UPDATE/COMPILE
	[!]
	/

# Also A9..95..D0  LDA #xx / STA 00,X / BNE
#A9 00/00 95 00/00 D0,6:
#	b8 [E+1]		# movl   $[E+1],%eax
#	8d 59 [B+3]		# leal   [B+3](%ecx),%ebx
#	bf [E+1]		# movl   $[E+1],%edi
#	81 e3 ff 00 00 00	# andl   $0xff,%ebx
#	8d 76 09		# leal   0x9(%esi),%esi
#	88 83 [L]		# movb   %al,[L](%ebx)
#	bb [R+5]		# movl   $[R+5],%ebx
#	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
#	e9 [U]			# jmp    [U]
#	[!]
#	/
#A9 00 95 00/00 D0,6:	# For LDA #00 case...
#	31 c0			# xorl   %eax,%eax
#	8d 59 [B+3]		# leal   [B+3](%ecx),%ebx
#	31 ff			# xorl   %edi,%edi
#	81 e3 ff 00 00 00	# andl   $0xff,%ebx
#	8d 76 08		# leal   0x8(%esi),%esi
#	88 83 [L]		# movb   %al,[L](%ebx)
#	/

# ORA of non-zero followed by BNE is always taken
09 00/00 D0,4:
	83 c8 [B+1]		# orl    $[B+1],%eax
	83 c6 [>+3] 05		# addl   $5+,%esi # do timing count
	0f be f8		# movsbl %al,%edi
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	bb [R+3]		# movl   $[R+3],%ebx
	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	[!]
	/
09 00 D0,4: # ORA #$00 / BNE  
	0f be f8		# movsbl %al,%edi
	83 c6 [>+3] 05		# addl   $5+,%esi # timing
	bb [P]			# movl   $[P],%ebx
	0f 89 [N]		# jns    NMI
	f7 c7 ff 00 00 00	# testl  $0xff,%edi
	bb [R+3]		# movl   $[R+3],%ebx
	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
	0f 85 [U]		# jne    [U]
	83 ee [>+3] 01		# subl   $1+,%esi
	/

# Branch pairs (one or the other is always taken)

# BNE/BEQ
#D0 00/00 F0,4:
#	83 c6 03		# addl   $3,%esi
#	bb [P]			# movl   $[P],%ebx
#	0f 89 [N]		# jns    NMI
#	f7 c7 ff 00 00 00	# testl  $0xff,%edi
#	bb [R+1]		# movl   $[R+1],%ebx
#	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
#	0f 85 [U]		# jne    U
#	83 c6 02		# addl   $2,%esi
#	bb [R+3]		# movl   $[R+3],%ebx
#	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
#	e9 [U]			# jmp    U
#	[!]			# STOP
#	/
# BEQ/BNE
#F0 00/00 D0,4:
#	83 c6 03		# addl   $3,%esi
#	bb [P]			# movl   $[P],%ebx
#	0f 89 [N]		# jns    NMI
#	f7 c7 ff 00 00 00	# testl  $0xff,%edi
#	bb [R+1]		# movl   $[R+1],%ebx
#	c7 44 24 fc [D+6]	# movl   $[D+6],0xfffffffc(%esp,1)
#	0f 84 [U]		# je     U
#	83 c6 02		# addl   $2,%esi
#	bb [R+3]		# movl   $[R+3],%ebx
#	c7 44 24 fc [D+5]	# movl   $[D+5],0xfffffffc(%esp,1)
#	e9 [U]			# jmp    U
#	[!]			# STOP
#	/

#-----------------------------------------------------------------------------
# Writes to Mapper Registers

# STA $8000+  - write mapper regs 
8D 00/00 80/80,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [Y]		# call   MAPPER
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/

# STX $8000+  - write mapper regs
8E 00/00 80/80,3:
	91              # xchgl  %eax,%ecx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $ADDR,%ebx
	e8 [Y]		# call   MAPPER
	91              # xchgl  %eax,%ecx
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/

# STY $8000+  - write mapper regs
8C 00/00 80/80,3:
	92              # xchgl  %eax,%edx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $ADDR,%ebx
	e8 [Y]		# call   MAPPER
	92              # xchgl  %eax,%edx
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/

# STA $8xxx,X  - write to mapper
9D 00/00 80/80,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c6 05		# addl   $0x5,%esi
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	e8 [Y]			# call   MAPPER
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/
# STA $8xxx,Y  - write to mapper
99 00/00 80/80,3:
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	83 c6 05		# addl   $0x5,%esi
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	e8 [Y]			# call   MAPPER
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/

# STA $7Fxx,X or $FFxx,X - possibly write to mapper
9D 00/00 7F/7F,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c6 05		# addl   $0x5,%esi
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	f7 c3 00 80 00 00	# testl  $0x8000,%ebx
	74 17			# je     +23
	e8 [Y]			# call   MAPPER
 	bb [P+3]		# movl   $[P+3],%ebx
 	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
 	e9 [U]			# jmp    [U]
	81 e3 ff ff 00 00	# andl   $0xffff,%ebx
	88 83 [L]		# movb   %al,[L](%ebx)
	/

# STA $7Fxx,Y or $FFxx,Y - possibly write to mapper
99 00/00 7F/7F,3:
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	83 c6 05		# addl   $0x5,%esi
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	f7 c3 00 80 00 00	# testl  $0x8000,%ebx
	74 17			# je     +23
	e8 [Y]			# call   MAPPER
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	81 e3 ff ff 00 00	# andl   $0xffff,%ebx
	88 83 [L]		# movb   %al,[L](%ebx)
 	/

# INC $8000+  - write mapper regs
#   Believe it or not, some games actually do this to write to the mapper.
#   Why?  Although it doesn't save any clock cycles, it does save a byte
#   of memory compared to the usual LDA/STA method.
EE 00/00 80/80,3:
	8b 1d [X+1]		# movl   [X+1],%ebx
	83 c6 06		# addl   $0x6,%esi
	50			# pushl  %eax
	0f b6 83 [W+1] 00 00	# movzbl ADDR(%ebx),%eax
	bb [W+1] 00 00		# movl   $ADDR,%ebx
	40			# incl   %eax
	0f be f8		# movsbl %al,%edi
	e8 [Y]			# call   [Y]
	58			# popl   %eax
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/

# DEC $8000+  - write mapper regs
CE 00/00 80/80,3:
	8b 1d [X+1]		# movl   [X+1],%ebx
	83 c6 06		# addl   $0x6,%esi
	50			# pushl  %eax
	0f b6 83 [W+1] 00 00	# movzbl ADDR(%ebx),%eax
	bb [W+1] 00 00		# movl   $ADDR,%ebx
	48			# decl   %eax
	0f be f8		# movsbl %al,%edi
	e8 [Y]			# call   [Y]
	58			# popl   %eax
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/

# INC $8000+,X to mapper
FE 00/00 80/80,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c6 07		# addl   $0x7,%esi
	8d b9 [W+1] 00 00	# leal   ADDR(%ecx),%edi
	50			# pushl  %eax
	89 fb			# movl   %edi,%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	8b 3c bd [M]		# movl   [M](,%edi,4),%edi
	0f b6 04 1f		# movzbl (%edi,%ebx,1),%eax
	40			# incl   %eax
	0f be f8		# movsbl %al,%edi
	e8 [Y]			# call   [Y]
	58			# popl   %eax
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/
 
# DEC $8000+,X to mapper
DE 00/00 80/80,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c6 07		# addl   $0x7,%esi
	8d b9 [W+1] 00 00	# leal   ADDR(%ecx),%edi
	50			# pushl  %eax
	89 fb			# movl   %edi,%ebx
	c1 ef 0c		# shrl   $0xc,%edi
	8b 3c bd [M]		# movl   [M](,%edi,4),%edi
	0f b6 04 1f		# movzbl (%edi,%ebx,1),%eax
	48			# decl   %eax
	0f be f8		# movsbl %al,%edi
	e8 [Y]			# call   [Y]
	58			# popl   %eax
	bb [P+3]		# movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00	# movl   $0,0xfffffffc(%esp,1)
	e9 [U]			# jmp    [U]
	/


#-----------------------------------------------------------------------------
# Special Cases for I/O

# LDA $2002 - PPU Status Register [PPUSTAT]
AD 02 20,3:
	8d 76 04	# leal   0x4(%esi),%esi # do timing count
	bb 02 20 00 00	# movl   $0x2002,%ebx
	e8 [I]		# call   INPUT
	89 f8		# movl   %edi,%eax
	/
# LDX $2002 - PPU Status Register [PPUSTAT]
AE 02 20,3:
	8d 76 04	# leal   0x4(%esi),%esi # do timing count
	bb 02 20 00 00	# movl   $0x2002,%ebx
	e8 [I]		# call   INPUT
	89 f9		# movl   %edi,%ecx
	/
# LDY $2002 - PPU Status Register [PPUSTAT]
AC 02 20,3:
	8d 76 04	# leal   0x4(%esi),%esi # do timing count
	bb 02 20 00 00	# movl   $0x2002,%ebx
	e8 [I]		# call   INPUT
	89 fa		# movl   %edi,%edx
	/
# BIT $2002 (Test PPU status)
2C 02 20,3:
	0d 00 ff ff ff		# orl    $0xffffff00,%eax
	bb 02 20 00 00		# movl   $0x2002,%ebx
	e8 [I]			# call   INPUT
	83 c6 04		# addl   $0x4,%esi
	8d 1c fd 00 00 00 00	# leal   0x0(,%edi,8),%ebx
	21 c7			# andl   %eax,%edi
	81 e3 00 02 00 00	# andl   $0x200,%ebx
	89 1d [V]		# movl   %ebx,VFLAG
	/

# LDA $2007 - Read VRAM
AD 07 20,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb 07 20 00 00	# movl   $0x2007,%ebx
	e8 [I]		# call   INPUT
	89 f8		# movl   %edi,%eax
	/
# LDX $2007 
AE 07 20,3:
	8d 76 04	# leal   0x4(%esi),%esi # do timing count
	bb 07 20 00 00	# movl   $0x2007,%ebx
	e8 [I]		# call   INPUT
	89 f9		# movl   %edi,%ecx
	/
# LDY $2007
AC 07 20,3:
	8d 76 04	# leal   0x4(%esi),%esi # do timing count
	bb 07 20 00 00	# movl   $0x2007,%ebx
	e8 [I]		# call   INPUT
	89 fa		# movl   %edi,%edx
	/

# ADC $2007
6D 07 20,3:
	0f be c0		# movsbl %al,%eax
	bb 07 20 00 00		# movl   $0x2007,%ebx
	e8 [I]			# call   INPUT
	83 c5 ff		# addl   $0xffffffff,%ebp
	11 f8			# adcl   %edi,%eax
	8d 76 04		# leal   0x4(%esi),%esi
	19 ed			# sbbl   %ebp,%ebp
	a3 [V]			# movl   %eax,VFLAG
	0f be f8		# movsbl %al,%edi
	/

# LDA $40xx - I/O read
AD 00/00 40,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [I]		# call   INPUT
	89 f8		# movl   %edi,%eax
	/
# AND $40xx - I/O read
2D 00/00 40,3:
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	0f be c0	# movsbl %al,%eax
	8d 76 04	# leal   0x4(%esi),%esi
	e8 [I]		# call   INPUT
	21 c7		# andl   %eax,%edi
	89 f8		# movl   %edi,%eax
	/
# LDA $40xx,x - I/O read
BD 00/00 40,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	bb [W+1] 00 00		# movl   $ADDR,%ebx
	8d 76 04		# leal   0x4(%esi),%esi #timing
	01 cb			# addl   %ecx,%ebx
	e8 [I]			# call   INPUT
	89 f8			# movl   %edi,%eax
	/
# LDA $40xx,y - I/O read
B9 00/00 40,3:
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	8d 76 04		# leal   0x4(%esi),%esi
	8d 9a [W+1] 00 00	# leal   $ADDR(%edx),%ebx
	e8 [I]			# call   INPUT
	89 f8			# movl   %edi,%eax
	/


# Output

# STA $2000  - write to $2000 
8D 00 20,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	/
# STX $2000  - write to $2000
8E 00 20,3:
	91              # xchgl  %eax,%ecx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2000,%ebx
	e8 [O]		# call   OUTPUT
	91              # xchgl  %eax,%ecx
	/
# STY $2000  - write to $2000
8C 00 20,3:
	92              # xchgl  %eax,%edx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2000,%ebx
	e8 [O]		# call   OUTPUT
	92              # xchgl  %eax,%edx
	/

# STA $2001  - write to $2001 
8D 01 20,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	/
# STX $2001  - write to $2001
8E 01 20,3:
	91              # xchgl  %eax,%ecx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2001,%ebx
	e8 [O]		# call   OUTPUT
	91              # xchgl  %eax,%ecx
	/
# STY $2001  - write to $2001
8C 01 20,3:
	92              # xchgl  %eax,%edx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2001,%ebx
	e8 [O]		# call   OUTPUT
	92              # xchgl  %eax,%edx
	/

# STA $2002  - write to $2002?? should not happen 
8D 02 20,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
#	bb [W+1] 00 00	# movl   $ADDR,%ebx
#	e8 [O]		# call   OUTPUT
	/

# STA $2003  - write to $2003 
8D 03 20,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	/
# STX $2003  - write to $2003
8E 03 20,3:
	91              # xchgl  %eax,%ecx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2003,%ebx
	e8 [O]		# call   OUTPUT
	91              # xchgl  %eax,%ecx
	/
# STY $2003  - write to $2003
8C 03 20,3:
	92              # xchgl  %eax,%edx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2003,%ebx
	e8 [O]		# call   OUTPUT
	92              # xchgl  %eax,%edx
	/

# STA $2004  - write to $2004 
8D 04 20,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	/
# STX $2004  - write to $2004
8E 04 20,3:
	91              # xchgl  %eax,%ecx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2004,%ebx
	e8 [O]		# call   OUTPUT
	91              # xchgl  %eax,%ecx
	/
# STY $2004  - write to $2004
8C 04 20,3:
	92              # xchgl  %eax,%edx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2004,%ebx
	e8 [O]		# call   OUTPUT
	92              # xchgl  %eax,%edx
	/

# STA $2005  - write to $2005 
8D 05 20,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	/
# STX $2005  - write to $2005
8E 05 20,3:
	91              # xchgl  %eax,%ecx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2005,%ebx
	e8 [O]		# call   OUTPUT
	91              # xchgl  %eax,%ecx
	/
# STY $2005  - write to $2005 
8C 05 20,3:
	92              # xchgl  %eax,%edx
	8d 76 04        # leal   0x4(%esi),%esi
	bb [W+1] 00 00  # movl   $0x2005,%ebx
	e8 [O]		# call   OUTPUT
	92              # xchgl  %eax,%edx
	/

# STA $2006  - write to $2006 
8D 06 20,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	/
# STX $2006  - write to $2006 
8E 06 20,3:
	8d 76 04        # leal   0x4(%esi),%esi
	91              # xchgl  %eax,%ecx
	bb 06 20 00 00  # movl   $0x2006,%ebx
	e8 [O]		# call   OUTPUT
	91              # xchgl  %eax,%ecx
	/
# STY $2006  - write to $2006 
8C 06 20,3:
	8d 76 04        # leal   0x4(%esi),%esi
	92              # xchgl  %eax,%edx
	bb 06 20 00 00  # movl   $0x2006,%ebx
	e8 [O]		# call   OUTPUT
	92              # xchgl  %eax,%edx
	/

# STA $2007  - write to $2007 
8D 07 20,3:
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	8d 76 04        # leal   0x4(%esi),%esi
	e8 [O]		# call   OUTPUT
	/
# STX $2007  - write to $2007 
8E 07 20,3:
	8d 76 04        # leal   0x4(%esi),%esi
	91              # xchgl  %eax,%ecx
	bb 07 20 00 00  # movl   $0x2007,%ebx
	e8 [O]		# call   OUTPUT
	91              # xchgl  %eax,%ecx
	/
# STY $2007  - write to $2007 
8C 07 20,3:
	8d 76 04        # leal   0x4(%esi),%esi
	92              # xchgl  %eax,%edx
	bb 07 20 00 00  # movl   $0x2007,%ebx
	e8 [O]		# call   OUTPUT
	92              # xchgl  %eax,%edx
	/

# STA $40xx - I/O write
8D 00/00 40,3:
	8d 76 04	# leal   0x4(%esi),%esi #timing
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	/
# STX $40xx - I/O write
8E 00/00 40,3:
	91		# xchgl  %eax,%ecx
	8d 76 04	# leal   0x4(%esi),%esi
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	91		# xchgl  %eax,%ecx
	/
# STY $40xx - I/O write
8C 00/00 40,3:
	92		# xchgl  %eax,%edx
	8d 76 04	# leal   0x4(%esi),%esi
	bb [W+1] 00 00	# movl   $ADDR,%ebx
	e8 [O]		# call   OUTPUT
	92		# xchgl  %eax,%edx
	/


# Indexed output

# STA $40xx,X
9D 00/00 40,3:
	81 e1 ff 00 00 00	# andl   $0xff,%ecx
	83 c6 05		# addl   $0x5,%esi
	8d 99 [W+1] 00 00	# leal   ADDR(%ecx),%ebx
	e8 [O]			# call   OUTPUT
	/
# STA $40xx,Y
99 00/00 40,3:
	81 e2 ff 00 00 00	# andl   $0xff,%edx
	83 c6 05		# addl   $0x5,%esi
	8d 9a [W+1] 00 00	# leal   ADDR(%edx),%ebx
	e8 [O]			# call   OUTPUT
	/
