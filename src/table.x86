# SPDX-FileCopyrightText: Authors of TuxNES
# SPDX-License-Identifier: GPL-2.0-or-later

# Description: Translation tables for 6502 to x86 dynamic recompiler

# This is the translation table for converting 6502 code into native code
# for x86 processors.  I have used the GNU standard for the representation
# of operands, which is: source,destination.  Be aware that Intel uses the
# opposite ordering in their documentation (destination precedes source).
#
# I have adopted the following register usage conventions:
#
#      A -> %eax            Carry flag -> %ebp
#      X -> %ecx     Zero & Sign flags -> %edi
#      Y -> %edx           Cycle count -> %esi
#
# The stack pointer and remaining flags are stored in memory.  The 6502
# program counter is loaded into %ebx when a branch occurs; at all other
# times, %ebx is used to hold various temporary values.  The carry flag
# is stored by setting %ebp to a nonzero value.  The %esi register is
# incremented to represent the 6502 cycle count.
#
# %edi is used to store the sign and zero flags.  This is usually done by
# sign-extending the result of arithmetic operations into %edi.  The
# equivalence branch instructions check the lower 8 bits of %edi against
# zero, and the sign branch instructions check bit 8 (0x100) of %edi.  While
# in many cases it would be sufficient to check only bit 7 to determine
# the sign, some 6502 instructions (such as BIT) can set the sign and zero
# flags independently, so a mechanism must be provided to accommodate this.
# Sign extension unfortunately is relatively slow (3 cycles) on a Pentium
# processor.  An alternative would be to store the sign and zero flags in
# separate memory locations, but as this would also require additional CPU
# cycles to read/write memory, I see little advantage in this approach,
# especially considering that the sign-extension can be precomputed for
# immediate data, thus eliminating the 3-cycle penalty for most data load
# operations.
#
# This file consists of a substitution table for replacing 6502 code with
# native equivalents.  The format is as follows:
#
# (6502 instruction bytes),length:  (native instruction bytes) /
#
# Each statement may span multiple lines and is terminated with a single
# slash mark.  All values are in hexadecimal.  The compdata.c program parses
# this file and compiles it into a binary search tree which is then linked
# into the final executable.  Anything following a # mark (such as this text)
# is ignored by the compiler.
#
# The source bytes may contain a pattern to be matched using an and-mask,
# which follows the instruction byte and a slash.  For example:
# 80/80 matches any value with the high bit set, 00/01 matches any even
# number, and 00/00 matches anything.
#
# The compiler can evaluate the following expressions in generating the
# translated code:
#
# [B+n] Byte at SRC+n, where SRC is the address of the 6502 instruction
# [C+n] Bitwise compliment of byte at SRC+n
# [W+n] 16-bit word at SRC+n
# [E+n] Byte at PC+n sign-extended to doubleword
# [Z+n] Zero Page Pointer to addr byte at SRC+n
# [A+n] Absolute address (word16 at SRC+n -> RAM address)
# [R+n] Relative branch address (byte at SRC+n converted to target address)
# [P+n] Current 6502 program counter +n (word16)
# [X+n] Precalculated remap table address for word16 at SRC+n
# [D+n] Destination address of translated code +n
# [>+n] Cycle count adjust (+1) for branch at SRC+n
# [V]   V-flag storage location
# [F]   Other flags storage location (process status register)
# [S]   Stack Pointer
# [T]   Top of stack (lowest address)
# [L]   Base of RAM (lowest address)
# [M]   Base address of mapper table
# [N]   Relative address of NMI/IRQ/refresh handler
# [I]   Relative address of input handler
# [O]   Relative address of output handler
# [U]   Relative address of unresolved address handler
# [Y]   Relative address of remapper
# [!]   Stop translating
# [^]   Insert breakpoint/trap
#
# To write to an output register, the generated code should put the location
# into %ebx and the value to write in %eax, and call [O].  (The compiler will
# replace [O] with the proper address.)  To read an input register, place the
# location into %ebx and call [I].  The value is returned in %edi.  For
# writes into the ROM area, call [Y] to pass these values to the mapper.
#
# Reads of memory are redirected thru the mapper table.  This table consists
# of 16 entries, each representing 4K of memory in the 6502 address space
# and containing a pointer to the actual memory location where the data can
# be found.  This table is used to emulate the function of the mapper chips
# found in many game cartridges.
#
# To execute a jump to a 6502 address, load the address into %ebx and jump
# to [U].  Also load the address of the operand of the jump instruction into
# %esp-4; that is, put it on top of the stack without modifying the stack
# pointer.  The Update function will translate any new code if necessary and
# resolve the 6502 target address into a native 32-bit address.  It will
# then use the value at %esp-4 to update the jump instruction to point to
# the new location.  For indirect jumps which can not be predicted, zero
# should be loaded into %esp-4, and the address will not be modified.  This
# may also be necessary if the target of the jump is swapped by the mapper.
#
# The %esi register is constantly incremented to reflect the 6502 cycle count.
# When this register exceeds 0xffffffff and wraps around, the program should
# jump to the NMI function [N].  This is done whether interrupts are enabled
# or not - this function updates the screen display and then generates a
# vblank NMI if appropriate.  In some cases the interrupt to be generated is
# actually an IRQ and not an NMI, but these are treated the same; the [N]
# function will determine which interrupt to generate, if any. (see x86.S)
#
# Note that this file is parsed beginning to end, with later statements
# overriding previous ones.  Therefore, general cases are defined first, and
# special cases last.
#
# Thanks to Matt Ghio for assembler coding help.
#
# Basic NES Memory Map:
#
# 0000-0800 - NES internal RAM
# 2000-2007 - I/O register area 1 (see io.c)
# 4000-4015 - I/O register area 2 (see io.c)
# 6000-7fff - Nonvolatile RAM for save data
# 8000-ffff - Reads ROM, writes output to mapper (see mapper.c)


# 00 - BRK
00,1:
	50                      # pushl  %eax
	a1 [S]                  # movl   STACKPTR,%eax
	bb [P+2]                # movl   $[P+2],%ebx
	88 38                   # movb   %bh,(%eax)
	fe c8                   # decb   %al
	88 18                   # movb   %bl,(%eax)
	fe c8                   # decb   %al
	8b 1d [F]               # movl   FLAGS,%ebx
	83 e3 0c                # andl   $0x0c,%ebx
	83 c5 ff                # addl   $-1,%ebp
	83 d3 00                # adcl   $0,%ebx
	89 fd                   # movl   %edi,%ebp
	d1 ed                   # shrl   %ebp
	81 e5 80 00 00 00       # andl   $0x80,%ebp
	09 dd                   # orl    %ebx,%ebp
	31 db                   # xorl   %ebx,%ebx
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	0f 94 c3                # setz   %bl
	8d 6c 5d 00             # leal   (%ebp,%ebx,2),%ebp
	8b 1d [V]               # movl   VFLAG,%ebx
	81 c3 80 00 00 00       # addl   $0x80,%ebx
	81 c3 00 ff ff ff       # addl   $-256,%ebx
	19 db                   # sbbl   %ebx,%ebx
	83 e3 40                # andl   $0x40,%ebx
	09 eb                   # orl    %ebp,%ebx
	83 e5 01                # andl   $0x1,%ebp
	83 cb 30                # orl    $0x30,%ebx
	83 0d [F] 04            # orl    $0x04,FLAGS
	88 18                   # movb   %bl,(%eax)
	fe c8                   # decb   %al
	a2 [S]                  # movb   %al,STACKPTR
	58                      # popl   %eax
	83 c6 07                # addl   $7,%esi
	bb [M]                  # movl   $MAPTABLE,%ebx
	8b 5b 3c                # movl   0x3c(%ebx),%ebx
	0f b7 9b fe ff 00 00    # movzwl 0xfffe(%ebx),%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	[!]                     #  -STOP-
	/
# 01 - ORA - (Indirect,X)
01,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	83 c6 06                # addl   $6,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0a 04 1f                # orb    (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 02 - (bad)
# 03 - (bad)
# 04 - (bad)
# 05 - ORA - Zero Page
05,2:
	0a 05 [Z+1]             # orb    [Z+1],%al
	0f be f8                # movsbl %al,%edi
	83 c6 03                # addl   $3,%esi
	/
# 06 - ASL - Zero Page
06,2:
	d0 25 [Z+1]             # shlb   [Z+1]
	0f be 3d [Z+1]          # movsbl [Z+1],%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 05                # addl   $5,%esi
	/
# 07 - (bad)
# 08 - PHP
08,1:
	8b 1d [F]               # movl   FLAGS,%ebx
	83 e3 0c                # andl   $0x0c,%ebx
	83 c5 ff                # addl   $-1,%ebp
	83 d3 00                # adcl   $0,%ebx
	89 fd                   # movl   %edi,%ebp
	d1 ed                   # shrl   %ebp
	81 e5 80 00 00 00       # andl   $0x80,%ebp
	09 dd                   # orl    %ebx,%ebp
	31 db                   # xorl   %ebx,%ebx
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	0f 94 c3                # setz   %bl
	8d 6c 5d 00             # leal   (%ebp,%ebx,2),%ebp
	8b 1d [V]               # movl   VFLAG,%ebx
	81 c3 80 00 00 00       # addl   $0x80,%ebx
	81 c3 00 ff ff ff       # addl   $-256,%ebx
	19 db                   # sbbl   %ebx,%ebx
	83 e3 40                # andl   $0x40,%ebx
	09 eb                   # orl    %ebp,%ebx
	83 cb 30                # orl    $0x30,%ebx
	8b 2d [S]               # movl   STACKPTR,%ebp
	88 5d 00                # movb   %bl,(%ebp)
	fe 0d [S]               # decb   STACKPTR
	83 e3 01                # andl   $0x1,%ebx
	89 dd                   # movl   %ebx,%ebp
	83 c6 03                # addl   $3,%esi
	/
# 09 - ORA - Immediate
09,2:
	0c [B+1]                # orb    $[B+1],%al
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
# 0a - ASL - Accumulator
0a,1:
	d0 e0                   # shlb   %al
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# 0b - (bad)
# 0c - (bad)
# 0d - ORA - Absolute
0d,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	0a 83 [W+1] 00 00       # orb    [W+1](%ebx),%al
	0f be f8                # movsbl %al,%edi
	83 c6 04                # addl   $4,%esi
	/
# 0e - ASL - Absolute
0e,3:
	# TODO: Check mapper
	d0 25 [A+1]             # shlb   [A+1]
	0f be 3d [A+1]          # movsbl [A+1],%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 06                # addl   $6,%esi
	/
# 0f - (bad)
# 10 - BPL
10,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 00 01 00 00       # testl  $0x100,%edi
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 84 [U]               # je     U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 11 - ORA - (Indirect),Y
11,2:
	bb [B+1] 00 00 00       # movl   $[B+1],%ebx
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	00 d3                   # addb   %dl,%bl
	80 d7 00                # adcb   $0,%bh
	38 d3                   # cmpb   %dl,%bl
	83 d6 05                # adcl   $5,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0a 04 1f                # orb    (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 12 - (bad)
# 13 - (bad)
# 14 - (bad)
# 15 - ORA - Zero Page,X
15,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	0a 83 [L]               # orb    RAM(%ebx),%al
	0f be f8                # movsbl %al,%edi
	/
# 16 - ASL - Zero Page,X
16,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	d0 a3 [L]               # shlb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 06                # addl   $6,%esi
	/
# 17 - (bad)
# 18 - CLC
18,1:
	31 ed                   # xorl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# 19 - ORA - Absolute,Y
19,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0a 04 1f                # orb    (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 1a - (bad)
# 1b - (bad)
# 1c - (bad)
# 1d - ORA - Absolute,X
1d,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	0a 04 1f                # orb    (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 1e - ASL - Absolute,X
1e,3:
	# TODO: Check mapper
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	d0 a3 [L]               # shlb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 07                # addl   $7,%esi
	/
# 1f - (bad)
# 20 - JSR
20,3:
	bb [P+2]                # movl   $[P+2],%ebx
	50                      # pushl  %eax
	a1 [S]                  # movl   STACKPTR,%eax
	88 38                   # movb   %bh,(%eax)
	fe c8                   # decb   %al
	88 18                   # movb   %bl,(%eax)
	fe c8                   # decb   %al
	a2 [S]                  # movb   %al,STACKPTR
	58                      # popl   %eax
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 06                # addl   $6,%esi
	0f 89 [N]               # jns    NMI
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]                     #  -STOP-
# It's fairly common for 6502 code to follow a JSR with parameter data,
# so there's a chance that what follows is not executable code, in which
# case translation should stop after the JSR.
	/
# 21 - AND - (Indirect,X)
21,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	83 c6 06                # addl   $6,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	22 04 1f                # andb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 22 - (bad)
# 23 - (bad)
# 24 - BIT - Zero Page
24,2:
	0f be 3d [Z+1]          # movsbl [Z+1],%edi
	8d 1c 3f                # leal   (%edi,%edi,1),%ebx
	81 e3 80 00 00 00       # andl   $0x80,%ebx
	89 1d [V]               # movl   %ebx,VFLAG
	0d 00 01 00 00          # orl    $0x100,%eax
	21 c7                   # andl   %eax,%edi
	83 c6 03                # addl   $3,%esi
	/
# 25 - AND - Zero Page
25,2:
	22 05 [Z+1]             # andb   [Z+1],%al
	0f be f8                # movsbl %al,%edi
	83 c6 03                # addl   $3,%esi
	/
# 26 - ROL - Zero Page
26,2:
	83 c5 ff                # addl   $-1,%ebp
	d0 15 [Z+1]             # rclb   [Z+1]
	0f be 3d [Z+1]          # movsbl [Z+1],%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 05                # addl   $5,%esi
	/
# 27 - (bad)
# 28 - PLP
28,1:
	8b 1d [S]               # movl   STACKPTR,%ebx
	fe c3                   # incb   %bl
	88 1d [S]               # movb   %bl,STACKPTR
	8b 2b                   # movl   (%ebx),%ebp
	89 2d [F]               # movl   %ebp,FLAGS
	8d 7c 2d 00             # leal   (%ebp,%ebp,1),%edi
	81 e7 80 00 00 00       # andl   $0x80,%edi
	89 3d [V]               # movl   %edi,VFLAG
	83 f5 02                # xorl   $0x2,%ebp
	8d 7c 2d 00             # leal   (%ebp,%ebp,1),%edi
	81 e7 04 01 00 00       # andl   $0x104,%edi
	83 e5 01                # andl   $0x1,%ebp
	83 c6 04                # addl   $4,%esi
	/
# 29 - AND - Immediate
29,2:
	24 [B+1]                # andb   $[B+1],%al
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
# 2a - ROL - Accumulator
2a,1:
	83 c5 ff                # addl   $-1,%ebp
	d0 d0                   # rclb   %al
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# 2b - (bad)
# 2c - BIT - Absolute
2c,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	0f be bb [W+1] 00 00    # movsbl [W+1](%ebx),%edi
	8d 1c 3f                # leal   (%edi,%edi,1),%ebx
	81 e3 80 00 00 00       # andl   $0x80,%ebx
	89 1d [V]               # movl   %ebx,VFLAG
	0d 00 01 00 00          # orl    $0x100,%eax
	21 c7                   # andl   %eax,%edi
	83 c6 04                # addl   $4,%esi
	/
# 2d - AND - Absolute
2d,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	22 83 [W+1] 00 00       # andb   [W+1](%ebx),%al
	0f be f8                # movsbl %al,%edi
	83 c6 04                # addl   $4,%esi
	/
# 2e - ROL - Absolute
2e,3:
	# TODO: Check mapper
	83 c5 ff                # addl   $-1,%ebp
	d0 15 [A+1]             # rclb   [A+1]
	0f be 3d [A+1]          # movsbl [A+1],%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 06                # addl   $6,%esi
	/
# 2f - (bad)
# 30 - BMI
30,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 00 01 00 00       # testl  $0x100,%edi
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 31 - AND - (Indirect),Y
31,2:
	bb [B+1] 00 00 00       # movl   $[B+1],%ebx
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	00 d3                   # addb   %dl,%bl
	80 d7 00                # adcb   $0,%bh
	38 d3                   # cmpb   %dl,%bl
	83 d6 05                # adcl   $5,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	22 04 1f                # andb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 32 - (bad)
# 33 - (bad)
# 34 - (bad)
# 35 - AND - Zero Page,X
35,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	22 83 [L]               # andb   RAM(%ebx),%al
	0f be f8                # movsbl %al,%edi
	/
# 36 - ROL - Zero Page,X
36,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c5 ff                # addl   $-1,%ebp
	d0 93 [L]               # rclb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 06                # addl   $6,%esi
	/
# 37 - (bad)
# 38 - SEC
38,1:
	83 cd ff                # orl    $-1,%ebp
	83 c6 02                # addl   $2,%esi
	/

# 39 - AND - Absolute,Y
39,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	22 04 1f                # andb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 3a - (bad)
# 3b - (bad)
# 3c - (bad)
# 3d - AND - Absolute,X
3d,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	22 04 1f                # andb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 3e - ROL - Absolute,X
3e,3:
	# TODO: Check mapper
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c5 ff                # addl   $-1,%ebp
	d0 93 [L]               # rclb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 07                # addl   $7,%esi
	/
# 3f - (bad)
# 40 - RTI
40,1:
	8b 1d [S]               # movl   STACKPTR,%ebx
	fe c3                   # incb   %bl
	8b 2b                   # movl   (%ebx),%ebp
	89 2d [F]               # movl   %ebp,FLAGS
	8d 7c 2d 00             # leal   (%ebp,%ebp,1),%edi
	81 e7 80 00 00 00       # andl   $0x80,%edi
	89 3d [V]               # movl   %edi,VFLAG
	83 f5 02                # xorl   $0x2,%ebp
	8d 7c 2d 00             # leal   (%ebp,%ebp,1),%edi
	81 e7 04 01 00 00       # andl   $0x104,%edi
	83 e5 01                # andl   $0x1,%ebp
	fe c3                   # incb   %bl
	8a 2b                   # movb   (%ebx),%ch
	fe c3                   # incb   %bl
	8a 33                   # movb   (%ebx),%dh
	88 1d [S]               # movb   %bl,STACKPTR
	31 db                   # xorl   %ebx,%ebx
	86 eb                   # xchgb  %ch,%bl
	86 f7                   # xchgb  %dh,%bh
	83 c6 06                # addl   $6,%esi
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# 41 - EOR - (Indirect,X)
41,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	83 c6 06                # addl   $6,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	32 04 1f                # xorb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 42 - (bad)
# 43 - (bad)
# 44 - (bad)
# 45 - EOR - Zero Page
45,2:
	32 05 [Z+1]             # xorb   [Z+1],%al
	0f be f8                # movsbl %al,%edi
	83 c6 03                # addl   $3,%esi
	/
# 46 - LSR - Zero Page
46,2:
	d0 2d [Z+1]             # shrb   [Z+1]
	0f be 3d [Z+1]          # movsbl [Z+1],%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 05                # addl   $5,%esi
	/
# 47 - (bad)
# 48 - PHA
48,1:
	8b 1d [S]               # movl   STACKPTR,%ebx
	88 03                   # movb   %al,(%ebx)
	fe cb                   # decb   %bl
	88 1d [S]               # movb   %bl,STACKPTR
	83 c6 03                # addl   $3,%esi
	/
# 49 - EOR - Immediate
49,2:
	34 [B+1]                # xorb   $[B+1],%al
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
# 4a - LSR - Accumulator
4a,1:
	d0 e8                   # shrb   %al
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# 4b - (bad)
# 4c - JMP - Absolute
4c,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 03                # addl   $3,%esi
	0f 89 [N]               # jns    NMI
	81 fb [P]               # cmpl   $[P],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	31 f6                   # xorl   %esi,%esi
	e9 [N]                  # jmp    NMI
	[!]
	/
# 4d - EOR - Absolute
4d,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	32 83 [W+1] 00 00       # xorb   [W+1](%ebx),%al
	0f be f8                # movsbl %al,%edi
	83 c6 04                # addl   $4,%esi
	/
# 4e - LSR - Absolute
4e,3:
	# TODO: Check mapper
	d0 2d [A+1]             # shrb   [A+1]
	0f be 3d [A+1]          # movsbl [A+1],%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 06                # addl   $6,%esi
	/
# 4f - (bad)
# 50 - BVC
50,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	8b 1d [V]               # movl   VFLAG,%ebx
	81 c3 80 00 00 00       # addl   $0x80,%ebx
	f7 c3 00 ff ff ff       # testl  $-256,%ebx
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 84 [U]               # je     U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 51 - EOR - (Indirect),Y
51,2:
	bb [B+1] 00 00 00       # movl   $[B+1],%ebx
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	00 d3                   # addb   %dl,%bl
	80 d7 00                # adcb   $0,%bh
	38 d3                   # cmpb   %dl,%bl
	83 d6 05                # adcl   $5,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	32 04 1f                # xorb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 52 - (bad)
# 53 - (bad)
# 54 - (bad)
# 55 - EOR - Zero Page,X
55,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	32 83 [L]               # xorb   RAM(%ebx),%al
	0f be f8                # movsbl %al,%edi
	/
# 56 - LSR - Zero Page,X
56,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	d0 ab [L]               # shrb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 06                # addl   $6,%esi
	/
# 57 - (bad)
# 58 - CLI
58,1:
	80 25 [F] fb            # andb   $0xfb,FLAGS
	83 c6 02                # addl   $2,%esi
	/
# 59 - EOR - Absolute,Y
59,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	32 04 1f                # xorb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 5a - (bad)
# 5b - (bad)
# 5c - (bad)
# 5d - EOR - Absolute,X
5d,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	32 04 1f                # xorb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# 5e - LSR - Absolute,X
5e,3:
	# TODO: Check mapper
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	d0 ab [L]               # shrb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 07                # addl   $7,%esi
	/
# 5f - (bad)
# 60 - RTS
60,1:
	31 db                   # xorl   %ebx,%ebx
	50                      # pushl  %eax
	a1 [S]                  # movl   STACKPTR,%eax
	fe c0                   # incb   %al
	8a 18                   # movb   (%eax),%bl
	fe c0                   # incb   %al
	8a 38                   # movb   (%eax),%bh
	a2 [S]                  # movb   %al,STACKPTR
	58                      # popl   %eax
	43                      # incl   %ebx
	83 c6 06                # addl   $6,%esi
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	[!]                     #  end of function; stop translating
	/
# 61 - ADC - (Indirect,X)
61,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	83 c6 06                # addl   $6,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# 62 - (bad)
# 63 - (bad)
# 64 - (bad)
# 65 - ADC - Zero Page
65,2:
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1d [Z+1]          # movsbl [Z+1],%ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 03                # addl   $3,%esi
	/
# 66 - ROR - Zero Page
66,2:
	83 c5 ff                # addl   $-1,%ebp
	d0 1d [Z+1]             # rcrb   [Z+1]
	0f be 3d [Z+1]          # movsbl [Z+1],%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 05                # addl   $5,%esi
	/
# 67 - (bad)
# 68 - PLA
68,1:
	a1 [S]                  # movl   STACKPTR,%eax
	fe c0                   # incb   %al
	a2 [S]                  # movb   %al,STACKPTR
	8a 00                   # movb   (%eax),%al
	0f be f8                # movsbl %al,%edi
	83 c6 04                # addl   $4,%esi
	/
# 69 - ADC - Immediate
69,2:
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	83 d0 [B+1]             # adcl   $[B+1],%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# 6a - ROR - Accumulator
6a,1:
	83 c5 ff                # addl   $-1,%ebp
	d0 d8                   # rcrb   %al
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# 6b - (bad)
# 6c - JMP - Indirect
6c,3:
	50                      # pushl  %eax
	57                      # pushl  %edi
	b8 [W+1] 00 00          # movl   $[W+1],%eax
	8b 3d [X+1]             # movl   [X+1],%edi
	31 db                   # xorl   %ebx,%ebx
	8a 1c 07                # movb   (%edi,%eax,1),%bl
	fe c0                   # incb   %al
	8a 3c 07                # movb   (%edi,%eax,1),%bh
	5f                      # popl   %edi
	58                      # popl   %eax
	83 c6 05                # addl   $5,%esi
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# 6d - ADC - Absolute
6d,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 9b [W+1] 00 00    # movsbl [W+1](%ebx),%ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# 6e - ROR - Absolute
6e,3:
	# TODO: Check mapper
	83 c5 ff                # addl   $-1,%ebp
	d0 1d [A+1]             # rcrb   [A+1]
	0f be 3d [A+1]          # movsbl [A+1],%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 06                # addl   $6,%esi
	/
# 6f - (bad)
# 70 - BVS
70,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	8b 1d [V]               # movl   VFLAG,%ebx
	81 c3 80 00 00 00       # addl   $0x80,%ebx
	f7 c3 00 ff ff ff       # testl  $-256,%ebx
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 71 - ADC - (Indirect),Y
71,2:
	bb [B+1] 00 00 00       # movl   $[B+1],%ebx
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	00 d3                   # addb   %dl,%bl
	80 d7 00                # adcb   $0,%bh
	38 d3                   # cmpb   %dl,%bl
	83 d6 05                # adcl   $5,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# 72 - (bad)
# 73 - (bad)
# 74 - (bad)
# 75 - ADC - Zero Page,X
75,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 9b [L]            # movsbl RAM(%ebx),%ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# 76 - ROR - Zero Page,X
76,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c5 ff                # addl   $-1,%ebp
	d0 9b [L]               # rcrb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 06                # addl   $6,%esi
	/
# 77 - (bad)
# 78 - SEI
78,1:
	80 0d [F] 04            # orb    $0x04,FLAGS
	83 c6 02                # addl   $2,%esi
	/

# 79 - ADC - Absolute,Y
79,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# 7a - (bad)
# 7b - (bad)
# 7c - (bad)
# 7d - ADC - Absolute,X
7d,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# 7e - ROR - Absolute,X
7e,3:
	# TODO: Check mapper
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c5 ff                # addl   $-1,%ebp
	d0 9b [L]               # rcrb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 07                # addl   $7,%esi
	/
# 7f - (bad)
# 80 - (bad)
# 81 - STA - (Indirect,X)
81,2:
	57                      # pushl  %edi
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	5f                      # popl   %edi
	83 c6 06                # addl   $6,%esi

	f7 c3 00 80 00 00       # testl  $0x8000,%ebx
	75 23                   # jne    +35
	81 eb 00 20 00 00       # subl   $0x2000,%ebx
	81 fb 00 40 00 00       # cmpl   $0x4000,%ebx
	8d 9b 00 20 00 00       # leal   0x2000(%ebx),%ebx
	72 08                   # jb     +8
	88 83 [L]               # movb   %al,RAM(%ebx)
	eb 0c                   # jmp    +12
	e8 [O]                  # call   OUTPUT
	eb 05                   # jmp    +5
	e8 [Y]                  # call   MAPPER
	/
# 82 - (bad)
# 83 - (bad)
# 84 - STY - Zero Page
84,2:
	88 15 [Z+1]             # movb   %dl,[Z+1]
	83 c6 03                # addl   $3,%esi
	/
# 85 - STA - Zero Page
85,2:
	a2 [Z+1]                # movb   %al,[Z+1]
	83 c6 03                # addl   $3,%esi
	/
# 86 - STX - Zero Page
86,2:
	88 0d [Z+1]             # movb   %cl,[Z+1]
	83 c6 03                # addl   $3,%esi
	/
# 87 - (bad)
# 88 - DEY
88,1:
	fe ca                   # decb   %dl
	0f be fa                # movsbl %dl,%edi
	83 c6 02                # addl   $2,%esi
	/
# 89 - (bad)
# 8a - TXA
8a,1:
	88 c8                   # movb   %cl,%al
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
# 8b - (bad)
# 8c - STY - Absolute
8c,3:
	88 15 [A+1]             # movb   %dl,[A+1]
	83 c6 04                # addl   $4,%esi
	/
# 8d - STA - Absolute
8d,3:
	a2 [A+1]                # movb   %al,[A+1]
	83 c6 04                # addl   $4,%esi
	/
# 8e - STX - Absolute
8e,3:
	88 0d [A+1]             # movb   %cl,[A+1]
	83 c6 04                # addl   $4,%esi
	/

# 8f - (bad)
# 90 - BCC
90,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	85 ed                   # testl  %ebp,%ebp
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 84 [U]               # je     U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# 91 - STA - (Indirect),Y
91,2:
	57                      # pushl  %edi
	bb [B+1] 00 00 00       # movl   $[B+1],%ebx
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	00 d3                   # addb   %dl,%bl
	80 d7 00                # adcb   $0,%bh
	5f                      # popl   %edi
	83 c6 06                # addl   $6,%esi

	f7 c3 00 80 00 00       # testl  $0x8000,%ebx
	75 23                   # jne    +35
	81 eb 00 20 00 00       # subl   $0x2000,%ebx
	81 fb 00 40 00 00       # cmpl   $0x4000,%ebx
	8d 9b 00 20 00 00       # leal   0x2000(%ebx),%ebx
	72 08                   # jb     +8
	88 83 [L]               # movb   %al,RAM(%ebx)
	eb 0c                   # jmp    +12
	e8 [O]                  # call   OUTPUT
	eb 05                   # jmp    +5
	e8 [Y]                  # call   MAPPER
	/
# 92 - (bad)
# 93 - (bad)
# 94 - STY - Zero Page,X
94,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	88 93 [L]               # movb   %dl,RAM(%ebx)
	/
# 95 - STA - Zero Page,X
95,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	88 83 [L]               # movb   %al,RAM(%ebx)
	/
# 96 - STX - Zero Page,Y
96,2:
	0f b6 da                # movzbl %dl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	88 8b [L]               # movb   %cl,RAM(%ebx)
	/
# 97 - (bad)
# 98 - TYA
98,1:
	88 d0                   # movb   %dl,%al
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
# 99 - STA - Absolute,Y
99,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 05                # addl   $5,%esi

	88 83 [L]               # movb   %al,RAM(%ebx)
	/
# 9a - TXS
9a,1:
	88 0d [S]               # movb   %cl,STACKPTR
	83 c6 02                # addl   $2,%esi
	/
# 9b - (bad)
# 9c - (bad)
# 9d - STA - Absolute,X
9d,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 05                # addl   $5,%esi

	88 83 [L]               # movb   %al,RAM(%ebx)
	/
# 9e - (bad)
# 9f - (bad)
# a0 - LDY - Immediate
a0,2:
	b2 [B+1]                # movb   $[B+1],%dl
	bf [E+1]                # movl   $[E+1],%edi
	83 c6 02                # addl   $2,%esi
	/
# a1 - LDA - (Indirect,X)
a1,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	83 c6 06                # addl   $6,%esi

	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 0b                   # jae    +11
	e8 [I]                  # call   INPUT
	89 fb                   # movl   %edi,%ebx
	88 d8                   # movb   %bl,%al
	eb 12                   # jmp    +18

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	8a 04 1f                # movb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# a2 - LDX - Immediate
a2,2:
	b1 [B+1]                # movb   $[B+1],%cl
	bf [E+1]                # movl   $[E+1],%edi
	83 c6 02                # addl   $2,%esi
	/
# a3 - (bad)
# a4 - LDY - Zero Page
a4,2:
	8a 15 [Z+1]             # movb   [Z+1],%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 03                # addl   $3,%esi
	/
# a5 - LDA - Zero Page
a5,2:
	a0 [Z+1]                # movb   [Z+1],%al
	0f be f8                # movsbl %al,%edi
	83 c6 03                # addl   $3,%esi
	/
# a6 - LDX - Zero Page
a6,2:
	8a 0d [Z+1]             # movb   [Z+1],%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 03                # addl   $3,%esi
	/
# a7 - (bad)
# a8 - TAY
a8,1:
	88 c2                   # movb   %al,%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 02                # addl   $2,%esi
	/
# a9 - LDA - Immediate
a9,2:
	b0 [B+1]                # movb   $[B+1],%al
	bf [E+1]                # movl   $[E+1],%edi
	83 c6 02                # addl   $2,%esi
	/
# aa - TAX
aa,1:
	88 c1                   # movb   %al,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 02                # addl   $2,%esi
	/
# ab - (bad)
# ac - LDY - Absolute
ac,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	8a 93 [W+1] 00 00       # movb   [W+1](%ebx),%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 04                # addl   $4,%esi
	/
# ad - LDA - Absolute
ad,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	8a 83 [W+1] 00 00       # movb   [W+1](%ebx),%al
	0f be f8                # movsbl %al,%edi
	83 c6 04                # addl   $4,%esi
	/
# ae - LDX - Absolute
ae,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	8a 8b [W+1] 00 00       # movb   [W+1](%ebx),%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 04                # addl   $4,%esi
	/
# af - (bad)
# b0 - BCS
b0,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	85 ed                   # testl  %ebp,%ebp
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# b1 - LDA - (Indirect),Y
b1,2:
	bb [B+1] 00 00 00       # movl   $[B+1],%ebx
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	00 d3                   # addb   %dl,%bl
	80 d7 00                # adcb   $0,%bh
	38 d3                   # cmpb   %dl,%bl
	83 d6 05                # adcl   $5,%esi

	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 0b                   # jae    +11
	e8 [I]                  # call   INPUT
	89 fb                   # movl   %edi,%ebx
	88 d8                   # movb   %bl,%al
	eb 12                   # jmp    +18

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	8a 04 1f                # movb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# b2 - (bad)
# b3 - (bad)
# b4 - LDY - Zero Page,X
b4,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	8a 93 [L]               # movb   RAM(%ebx),%dl
	0f be fa                # movsbl %dl,%edi
	/
# b5 - LDA - Zero Page,X
b5,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	8a 83 [L]               # movb   RAM(%ebx),%al
	0f be f8                # movsbl %al,%edi
	/
# b6 - LDX - Zero Page,Y
b6,2:
	0f b6 da                # movzbl %dl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	8a 8b [L]               # movb   RAM(%ebx),%cl
	0f be f9                # movsbl %cl,%edi
	/
# b7 - (bad)
# b8 - CLV
b8,1:
	c7 05 [V] 00 00 00 00   # movl   $0,VFLAG
	83 c6 02                # addl   $2,%esi
	/
# b9 - LDA - Absolute,Y
b9,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	8a 04 1f                # movb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# ba - TSX
ba,1:
	8a 0d [S]               # movb   STACKPTR,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 02                # addl   $2,%esi
	/
# bb - (bad)
# bc - LDY - Absolute,X
bc,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	8a 14 1f                # movb   (%edi,%ebx,1),%dl
	0f be fa                # movsbl %dl,%edi
	/
# bd - LDA - Absolute,X
bd,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	8a 04 1f                # movb   (%edi,%ebx,1),%al
	0f be f8                # movsbl %al,%edi
	/
# be - LDX - Absolute,Y
be,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	8a 0c 1f                # movb   (%edi,%ebx,1),%cl
	0f be f9                # movsbl %cl,%edi
	/
# bf - (bad)
# c0 - CPY - Immediate
c0,2:
	88 d3                   # movb   %dl,%bl
	80 eb [B+1]             # subb   $[B+1],%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# c1 - CMP - (Indirect,X)
c1,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	83 c6 06                # addl   $6,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $12,%ebx
	8b 2c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebp
	88 c3                   # movb   %al,%bl
	2a 5c 3d 00             # subb   (%ebp,%edi,1),%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# c2 - (bad)
# c3 - (bad)
# c4 - CPY - Zero Page
c4,2:
	88 d3                   # movb   %dl,%bl
	2a 1d [Z+1]             # subb   [Z+1],%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 03                # addl   $3,%esi
	/
# c5 - CMP - Zero Page
c5,2:
	88 c3                   # movb   %al,%bl
	2a 1d [Z+1]             # subb   [Z+1],%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 03                # addl   $3,%esi
	/
# c6 - DEC - Zero Page
c6,2:
	fe 0d [Z+1]             # decb   [Z+1]
	0f be 3d [Z+1]          # movsbl [Z+1],%edi
	83 c6 05                # addl   $5,%esi
	/
# c7 - (bad)
# c8 - INY
c8,1:
	fe c2                   # incb   %dl
	0f be fa                # movsbl %dl,%edi
	83 c6 02                # addl   $2,%esi
	/
# c9 - CMP - Immediate
c9,2:
	88 c3                   # movb   %al,%bl
	80 eb [B+1]             # subb   $[B+1],%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# ca - DEX
ca,1:
	fe c9                   # decb   %cl
	0f be f9                # movsbl %cl,%edi
	83 c6 02                # addl   $2,%esi
	/
# cb - (bad)
# cc - CPY - Absolute
cc,3:
	88 d3                   # movb   %dl,%bl
	8b 3d [X+1]             # movl   [X+1],%edi
	2a 9f [W+1] 00 00       # subb   [W+1](%edi),%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# cd - CMP - Absolute
cd,3:
	88 c3                   # movb   %al,%bl
	8b 3d [X+1]             # movl   [X+1],%edi
	2a 9f [W+1] 00 00       # subb   [W+1](%edi),%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# ce - DEC - Absolute
ce,3:
	fe 0d [A+1]             # decb   [A+1]
	0f be 3d [A+1]          # movsbl [A+1],%edi
	83 c6 06                # addl   $6,%esi
	/
# cf - (bad)
# d0 - BNE
d0,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# d1 - CMP - (Indirect),Y
d1,2:
	bb [B+1] 00 00 00       # movl   $[B+1],%ebx
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	00 d3                   # addb   %dl,%bl
	80 d7 00                # adcb   $0,%bh
	38 d3                   # cmpb   %dl,%bl
	83 d6 05                # adcl   $5,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $12,%ebx
	8b 2c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebp
	88 c3                   # movb   %al,%bl
	2a 5c 3d 00             # subb   (%ebp,%edi,1),%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# d2 - (bad)
# d3 - (bad)
# d4 - (bad)
# d5 - CMP - Zero Page,X
d5,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 04                # addl   $4,%esi

	89 df                   # movl   %ebx,%edi
	88 c3                   # movb   %al,%bl
	2a 9f [L]               # subb   RAM(%edi),%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# d6 - DEC - Zero Page,X
d6,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 06                # addl   $6,%esi

	fe 8b [L]               # decb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	/
# d7 - (bad)
# d8 - CLD
d8,1:
	80 25 [F] f7            # andb   $0xf7,FLAGS
	83 c6 02                # addl   $2,%esi
	/
# d9 - CMP - Absolute,Y
d9,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $12,%ebx
	8b 2c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebp
	88 c3                   # movb   %al,%bl
	2a 5c 3d 00             # subb   (%ebp,%edi,1),%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# da - (bad)
# db - (bad)
# dc - (bad)
# dd - CMP - Absolute,X
dd,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 eb 0c                # shrl   $12,%ebx
	8b 2c 9d [M]            # movl   MAPTABLE(,%ebx,4),%ebp
	88 c3                   # movb   %al,%bl
	2a 5c 3d 00             # subb   (%ebp,%edi,1),%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# de - DEC - Absolute,X
de,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 07                # addl   $7,%esi

	fe 8b [L]               # decb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	/
# df - (bad)
# e0 - CPX - Immediate
e0,2:
	88 cb                   # movb   %cl,%bl
	80 eb [B+1]             # subb   $[B+1],%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# e1 - SBC - (Indirect,X)
e1,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	83 c6 06                # addl   $6,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# e2 - (bad)
# e3 - (bad)
# e4 - CPX - Zero Page
e4,2:
	88 cb                   # movb   %cl,%bl
	2a 1d [Z+1]             # subb   [Z+1],%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 03                # addl   $3,%esi
	/
# e5 - SBC - Zero Page
e5,2:
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1d [Z+1]          # movsbl [Z+1],%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 03                # addl   $3,%esi
	/
# e6 - INC - Zero Page
e6,2:
	fe 05 [Z+1]             # incb   [Z+1]
	0f be 3d [Z+1]          # movsbl [Z+1],%edi
	83 c6 05                # addl   $5,%esi
	/
# e7 - (bad)
# e8 - INX
e8,1:
	fe c1                   # incb   %cl
	0f be f9                # movsbl %cl,%edi
	83 c6 02                # addl   $2,%esi
	/
# e9 - SBC - Immediate
e9,2:
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	83 d0 [C+1]             # adcl   $[C+1],%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 02                # addl   $2,%esi
	/
# ea - NOP
ea,1:
	83 c6 02                # addl   $2,%esi
	/
# eb - (bad)
# ec - CPX - Absolute
ec,3:
	88 cb                   # movb   %cl,%bl
	8b 3d [X+1]             # movl   [X+1],%edi
	2a 9f [W+1] 00 00       # subb   [W+1](%edi),%bl
	f5                      # cmc
	0f be fb                # movsbl %bl,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# ed - SBC - Absolute
ed,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 9b [W+1] 00 00    # movsbl [W+1](%ebx),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# ee - INC - Absolute
ee,3:
	fe 05 [A+1]             # incb   [A+1]
	0f be 3d [A+1]          # movsbl [A+1],%edi
	83 c6 06                # addl   $6,%esi
	/
# ef - (bad)
# f0 - BEQ
f0,2:
	83 c6 [>+1] 03          # addl   $3+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	bb [R+1]                # movl   $[R+1],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 84 [U]               # je     U
	83 ee [>+1] 01          # subl   $1+,%esi
	/
# f1 - SBC - (Indirect),Y
f1,2:
	bb [B+1] 00 00 00       # movl   $[B+1],%ebx
	89 df                   # movl   %ebx,%edi
	fe c3                   # incb   %bl
	87 df                   # xchgl  %ebx,%edi
	8a 9b [L]               # movb   RAM(%ebx),%bl
	8a bf [L]               # movb   RAM(%edi),%bh
	00 d3                   # addb   %dl,%bl
	80 d7 00                # adcb   $0,%bh
	38 d3                   # cmpb   %dl,%bl
	83 d6 05                # adcl   $5,%esi

	# FIXME: Trap I/O
	8d bb 00 e0 ff ff       # leal   -0x2000(%ebx),%edi
	81 ff 00 40 00 00       # cmpl   $0x4000,%edi
	73 01                   # jae    +1
	[^]                     # int3

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# f2 - (bad)
# f3 - (bad)
# f4 - (bad)
# f5 - SBC - Zero Page,X
f5,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 9b [L]            # movsbl RAM(%ebx),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# f6 - INC - Zero Page,X
f6,2:
	0f b6 d9                # movzbl %cl,%ebx
	80 c3 [B+1]             # addb   $[B+1],%bl
	83 c6 06                # addl   $6,%esi

	fe 83 [L]               # incb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	/
# f7 - (bad)
# f8 - SED
f8,1: #What happens on a real NES when the CPU is put into decimal mode?
	80 0d [F] 08            # orb    $0x08,FLAGS
	83 c6 02                # addl   $2,%esi
	/
# f9 - SBC - Absolute,Y
f9,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# fa - (bad)
# fb - (bad)
# fc - (bad)
# fd - SBC - Absolute,X
fd,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	0f be 1c 1f             # movsbl (%edi,%ebx,1),%ebx
	f7 d3                   # notl   %ebx
	11 d8                   # adcl   %ebx,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/
# fe - INC - Absolute,X
fe,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 07                # addl   $7,%esi

	fe 83 [L]               # incb   RAM(%ebx)
	0f be bb [L]            # movsbl RAM(%ebx),%edi
	/
# ff - (bad)

#-----------------------------------------------------------------------------
# Specific Optimizations

# movsx is slow (3 cycles on a Pentium) so we eliminate it whenever possible:

09 80/80,2: # ORA with a negative is always negative (and nonzero)
	0c [B+1]                # orb    $[B+1],%al
	bf ff ff ff ff          # movl   $-1,%edi
	83 c6 02                # addl   $2,%esi
	/
09/bf 00/ff,2: # ORA/EOR #$00  (set flags only)
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
09 ff/ff,2: # ORA #$ff  (set all bits)
	b0 ff                   # movb   $0xff,%al
	bf ff ff ff ff          # movl   $-1,%edi
	83 c6 02                # addl   $2,%esi
	/
29 00/80,2: # AND with a positive value is always positive (sign flag=0)
	25 [E+1]                # andl   $[E+1],%eax
	89 c7                   # movl   %eax,%edi
	83 c6 02                # addl   $2,%esi
	/
29 00/ff,2: # AND #$00  (clear registers only)
	30 c0                   # xorb   %al,%al
	31 ff                   # xorl   %edi,%edi
	83 c6 02                # addl   $2,%esi
	/
29 ff/ff,2: # AND #$ff  (set flags only)
	0f be f8                # movsbl %al,%edi
	83 c6 02                # addl   $2,%esi
	/
a9 00,2: # LDA #$00  (clear registers only, same as AND #0)
	30 c0                   # xorb   %al,%al
	31 ff                   # xorl   %edi,%edi
	83 c6 02                # addl   $2,%esi
	/
a2 00,2: # LDX #$00  (clear registers)
	30 c9                   # xorb   %cl,%cl
	31 ff                   # xorl   %edi,%edi
	83 c6 02                # addl   $2,%esi
	/
a0 00,2: # LDY #$00  (clear registers)
	30 d2                   # xorb   %dl,%dl
	31 ff                   # xorl   %edi,%edi
	83 c6 02                # addl   $2,%esi
	/

# CLC followed by ADC -> ADD
18 69,3:
	0f be c0                # movsbl %al,%eax
	83 c0 [B+2]             # addl   $[B+2],%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/
# SEC followed by SBC -> SUB
31 e9,3:
	0f be c0                # movsbl %al,%eax
	83 e8 [B+2]             # subl   $[B+2],%eax
	f5                      # cmc
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	83 c6 04                # addl   $4,%esi
	/

# Repeated NOP
ea ea,2:
	83 c6 04                # addl   $4,%esi
	/
ea ea ea,3:
	83 c6 06                # addl   $6,%esi
	/
ea ea ea ea,4:
	83 c6 08                # addl   $8,%esi
	/

# Repeated INX
e8 e8,2:
	80 c1 02                # addb   $2,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 04                # addl   $4,%esi
	/
e8 e8 e8,3:
	80 c1 03                # addb   $3,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 06                # addl   $6,%esi
	/
e8 e8 e8 e8,4:
	80 c1 04                # addb   $4,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 08                # addl   $8,%esi
	/

# Repeated INY
c8 c8,2:
	80 c2 02                # addb   $2,%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 04                # addl   $4,%esi
	/
c8 c8 c8,3:
	80 c2 03                # addb   $3,%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 06                # addl   $6,%esi
	/
c8 c8 c8 c8,4:
	80 c2 04                # addb   $4,%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 08                # addl   $8,%esi
	/

# Repeated DEX
ca ca,2:
	80 e9 02                # subb   $2,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 04                # addl   $4,%esi
	/
ca ca ca,3:
	80 e9 03                # subb   $3,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 06                # addl   $6,%esi
	/
ca ca ca ca,4:
	80 e9 04                # subb   $4,%cl
	0f be f9                # movsbl %cl,%edi
	83 c6 08                # addl   $8,%esi
	/

# Repeated DEY
88 88,2:
	80 ea 02                # subb   $2,%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 04                # addl   $4,%esi
	/
88 88 88,3:
	80 ea 03                # subb   $3,%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 06                # addl   $6,%esi
	/
88 88 88 88,4:
	80 ea 04                # subb   $4,%dl
	0f be fa                # movsbl %dl,%edi
	83 c6 08                # addl   $8,%esi
	/

# Repeated ASL
0a 0a,2:
	c0 e0 02                # shlb   $2,%al
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	83 c6 04                # addl   $4,%esi
	/
0a 0a 0a,3:
	c0 e0 03                # shlb   $3,%al
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	83 c6 06                # addl   $6,%esi
	/
0a 0a 0a 0a,4:
	c0 e0 04                # shlb   $4,%al
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	83 c6 08                # addl   $8,%esi
	/

# Repeated LSR
4a 4a,2:
	c0 e8 02                # shrb   $2,%al
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	83 c6 04                # addl   $4,%esi
	/
4a 4a 4a,3:
	c0 e8 03                # shrb   $3,%al
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	83 c6 06                # addl   $6,%esi
	/
4a 4a 4a 4a,4:
	c0 e8 04                # shrb   $4,%al
	19 ed                   # sbbl   %ebp,%ebp
	0f be f8                # movsbl %al,%edi
	83 c6 08                # addl   $8,%esi
	/


# Predictable branches.  Sometimes a 'conditional' branch is in fact always
# taken.  It is good to recognize these cases, because the branch may be
# followed by non-executable data, which we don't want to try to translate.

# LDA of non-zero followed by BNE is always taken
a9 00/00 d0,4:
	b0 [B+1]                # movb   $[B+1],%al
	bf [E+1]                # movl   $[E+1],%edi
	83 c6 [>+3] 05          # addl   $5+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDA #0 followed by BNE is never taken (overrides previous case for LDA #0)
a9 00 d0,4:
	30 c0                   # xorb   %al,%al
	31 ff                   # xorl   %edi,%edi
	83 c6 04                # addl   $4,%esi
	/
# LDX of non-zero followed by BNE is always taken
a2 00/00 d0,4:
	b1 [B+1]                # movb   $[B+1],%cl
	bf [E+1]                # movl   $[E+1],%edi
	83 c6 [>+3] 05          # addl   $5+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDX #0 followed by BNE is never taken (overrides previous case for LDX #0)
a2 00 d0,4:
	30 c9                   # xorb   %cl,%cl
	31 ff                   # xorl   %edi,%edi
	83 c6 04                # addl   $4,%esi
	/

# LDY of non-zero followed by BNE is always taken
a0 00/00 d0,4:
	b2 [B+1]                # movb   $[B+1],%dl
	bf [E+1]                # movl   $[E+1],%edi
	83 c6 [>+3] 05          # addl   $5+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDY #0 followed by BNE is never taken (overrides previous case for LDY #0)
a0 00 d0,4:
	30 d2                   # xorb   %dl,%dl
	31 ff                   # xorl   %edi,%edi
	83 c6 04                # addl   $4,%esi
	/

# LDA #0 followed by BEQ is always taken
a9 00 f0,4:
	30 c0                   # xorb   %al,%al
	31 ff                   # xorl   %edi,%edi
	83 c6 [>+3] 05          # addl   $5+,%esi
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDX #0 followed by BEQ is always taken
a2 00 f0,4:
	30 c9                   # xorb   %cl,%cl
	31 ff                   # xorl   %edi,%edi
	83 c6 [>+3] 05          # addl   $5+,%esi
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
# LDY #0 followed by BEQ is always taken
a0 00 f0,4:
	30 d2                   # xorb   %dl,%dl
	31 ff                   # xorl   %edi,%edi
	83 c6 [>+3] 05          # addl   $5+,%esi
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/

# This shows up quite a bit also... LDA #0 / STA / BEQ
a9 00 85 00/00 f0,6:
	30 c0                   # xorb   %al,%al
	31 ff                   # xorl   %edi,%edi
	a2 [Z+3]                # movb   %al,[Z+3]
	83 c6 [>+5] 08          # addl   $8+,%esi
	bb [R+5]                # movl   $[R+5],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/

# Also a9..95..d0  LDA #xx / STA 00,X / BNE
#a9 00/00 95 00/00 d0,6:
#	b0 [B+1]                # movb   $[B+1],%al
#	bf [E+1]                # movl   $[E+1],%edi
#	0f b6 d9                # movzbl %cl,%ebx
#	80 c3 [B+3]             # addb   $[B+3],%bl
#	88 83 [L]               # movb   %al,RAM(%ebx)
#	83 c6 [>+5] 09          # addl   $9+,%esi
#	bb [R+5]                # movl   $[R+5],%ebx
#	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
#	e9 [U]                  # jmp    U
#	[!]
#	/
#a9 00 95 00/00 d0,6:   # For LDA #00 case...
#	30 c0                   # xorb   %al,%al
#	31 ff                   # xorl   %edi,%edi
#	0f b6 d9                # movzbl %cl,%ebx
#	80 c3 [B+3]             # addb   $[B+3],%bl
#	88 83 [L]               # movb   %al,RAM(%ebx)
#	83 c6 08                # addl   $8,%esi
#	/

# ORA of non-zero followed by BNE is always taken
09 00/00 d0,4:
	0c [B+1]                # orb    $[B+1],%al
	0f be f8                # movsbl %al,%edi
	83 c6 [>+3] 05          # addl   $5+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
	e9 [U]                  # jmp    U
	[!]
	/
09 00 d0,4: # ORA #$00 / BNE
	0f be f8                # movsbl %al,%edi
	83 c6 [>+3] 05          # addl   $5+,%esi
	bb [P]                  # movl   $[P],%ebx
	0f 89 [N]               # jns    NMI
	f7 c7 ff 00 00 00       # testl  $0xff,%edi
	bb [R+3]                # movl   $[R+3],%ebx
	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
	0f 85 [U]               # jne    U
	83 ee [>+3] 01          # subl   $1+,%esi
	/

# Branch pairs (one or the other is always taken)

# BNE/BEQ
#d0 00/00 f0,4:
#	83 c6 03                # addl   $3,%esi
#	bb [P]                  # movl   $[P],%ebx
#	0f 89 [N]               # jns    NMI
#	f7 c7 ff 00 00 00       # testl  $0xff,%edi
#	bb [R+1]                # movl   $[R+1],%ebx
#	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
#	0f 85 [U]               # jne    U
#	83 c6 02                # addl   $2,%esi
#	bb [R+3]                # movl   $[R+3],%ebx
#	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
#	e9 [U]                  # jmp    U
#	[!]                     # STOP
#	/
# BEQ/BNE
#f0 00/00 d0,4:
#	83 c6 03                # addl   $3,%esi
#	bb [P]                  # movl   $[P],%ebx
#	0f 89 [N]               # jns    NMI
#	f7 c7 ff 00 00 00       # testl  $0xff,%edi
#	bb [R+1]                # movl   $[R+1],%ebx
#	c7 44 24 fc [D+6]       # movl   $[D+6],-4(%esp)
#	0f 84 [U]               # je     U
#	83 c6 02                # addl   $2,%esi
#	bb [R+3]                # movl   $[R+3],%ebx
#	c7 44 24 fc [D+5]       # movl   $[D+5],-4(%esp)
#	e9 [U]                  # jmp    U
#	[!]                     # STOP
#	/

#-----------------------------------------------------------------------------
# Writes to Mapper Registers

# STA $8000+  - write mapper regs
8d 00/00 80/80,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 04                # addl   $4,%esi

	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# STX $8000+  - write mapper regs
8e 00/00 80/80,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [Y]                  # call   MAPPER
	86 c1                   # xchgb  %al,%cl
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# STY $8000+  - write mapper regs
8c 00/00 80/80,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [Y]                  # call   MAPPER
	86 c2                   # xchgb  %al,%dl
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# STA $8xxx,X  - write to mapper
9d 00/00 80/80,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 05                # addl   $5,%esi

	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/
# STA $8xxx,Y  - write to mapper
99 00/00 80/80,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 05                # addl   $5,%esi

	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# STA $7fxx,X or $ffxx,X - possibly write to mapper
9d 00/00 7f/7f,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 05                # addl   $5,%esi

	f7 c3 00 80 00 00       # testl  $0x8000,%ebx
	74 17                   # je     +23
	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	88 83 [L]               # movb   %al,RAM(%ebx)
	/

# STA $7fxx,Y or $ffxx,Y - possibly write to mapper
99 00/00 7f/7f,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 05                # addl   $5,%esi

	f7 c3 00 80 00 00       # testl  $0x8000,%ebx
	74 17                   # je     +23
	e8 [Y]                  # call   MAPPER
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	88 83 [L]               # movb   %al,RAM(%ebx)
	/

# INC $8000+  - write mapper regs
#   Believe it or not, some games actually do this to write to the mapper.
#   Why?  Although it doesn't save any clock cycles, it does save a byte
#   of memory compared to the usual LDA/STA method.
ee 00/00 80/80,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	83 c6 06                # addl   $6,%esi

	50                      # pushl  %eax
	0f b6 83 [W+1] 00 00    # movzbl [W+1](%ebx),%eax
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	fe c0                   # incb   %al
	0f be f8                # movsbl %al,%edi
	e8 [Y]                  # call   MAPPER
	58                      # popl   %eax
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# DEC $8000+  - write mapper regs
ce 00/00 80/80,3:
	8b 1d [X+1]             # movl   [X+1],%ebx
	83 c6 06                # addl   $6,%esi

	50                      # pushl  %eax
	0f b6 83 [W+1] 00 00    # movzbl [W+1](%ebx),%eax
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	fe c8                   # decb   %al
	0f be f8                # movsbl %al,%edi
	e8 [Y]                  # call   MAPPER
	58                      # popl   %eax
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# INC $8000+,X to mapper
fe 00/00 80/80,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 07                # addl   $7,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	50                      # pushl  %eax
	0f b6 04 1f             # movzbl (%edi,%ebx,1),%eax
	fe c0                   # incb   %al
	0f be f8                # movsbl %al,%edi
	e8 [Y]                  # call   MAPPER
	58                      # popl   %eax
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/

# DEC $8000+,X to mapper
de 00/00 80/80,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 07                # addl   $7,%esi

	89 df                   # movl   %ebx,%edi
	c1 ef 0c                # shrl   $12,%edi
	8b 3c bd [M]            # movl   MAPTABLE(,%edi,4),%edi
	50                      # pushl  %eax
	0f b6 04 1f             # movzbl (%edi,%ebx,1),%eax
	fe c8                   # decb   %al
	0f be f8                # movsbl %al,%edi
	e8 [Y]                  # call   MAPPER
	58                      # popl   %eax
	bb [P+3]                # movl   $[P+3],%ebx
	c7 44 24 fc 00 00 00 00 # movl   $0,-4(%esp)
	e9 [U]                  # jmp    U
	/


#-----------------------------------------------------------------------------
# Special Cases for I/O

# LDA $2002 - PPU Status Register [PPUSTAT]
ad 02 20,3:
	bb 02 20 00 00          # movl   $0x2002,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/
# LDX $2002 - PPU Status Register [PPUSTAT]
ae 02 20,3:
	bb 02 20 00 00          # movl   $0x2002,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	89 f9                   # movl   %edi,%ecx
	/
# LDY $2002 - PPU Status Register [PPUSTAT]
ac 02 20,3:
	bb 02 20 00 00          # movl   $0x2002,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	89 fa                   # movl   %edi,%edx
	/
# BIT $2002 (Test PPU status)
2c 02 20,3:
	bb 02 20 00 00          # movl   $0x2002,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	8d 1c 3f                # leal   (%edi,%edi,1),%ebx
	81 e3 80 00 00 00       # andl   $0x80,%ebx
	89 1d [V]               # movl   %ebx,VFLAG
	0d 00 01 00 00          # orl    $0x100,%eax
	21 c7                   # andl   %eax,%edi
	/

# LDA $2007 - Read VRAM
ad 07 20,3:
	bb 07 20 00 00          # movl   $0x2007,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/
# LDX $2007
ae 07 20,3:
	bb 07 20 00 00          # movl   $0x2007,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	89 f9                   # movl   %edi,%ecx
	/
# LDY $2007
ac 07 20,3:
	bb 07 20 00 00          # movl   $0x2007,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	89 fa                   # movl   %edi,%edx
	/

# ADC $2007
6d 07 20,3:
	bb 07 20 00 00          # movl   $0x2007,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	83 c5 ff                # addl   $-1,%ebp
	0f be c0                # movsbl %al,%eax
	11 f8                   # adcl   %edi,%eax
	a3 [V]                  # movl   %eax,VFLAG
	0f be f8                # movsbl %al,%edi
	19 ed                   # sbbl   %ebp,%ebp
	/

# LDA $40xx - I/O read
ad 00/00 40,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/
# AND $40xx - I/O read
2d 00/00 40,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 04                # addl   $4,%esi

	e8 [I]                  # call   INPUT
	89 fb                   # movl   %edi,%ebx
	20 d8                   # andb   %bl,%al
	0f be f8                # movsbl %al,%edi
	/
# LDA $40xx,x - I/O read
bd 00/00 40,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 cb                   # cmpb   %cl,%bl
	83 d6 04                # adcl   $4,%esi

	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/
# LDA $40xx,y - I/O read
b9 00/00 40,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	38 d3                   # cmpb   %dl,%bl
	83 d6 04                # adcl   $4,%esi

	e8 [I]                  # call   INPUT
	89 f8                   # movl   %edi,%eax
	/


# Output

# STA $2000  - write to $2000
8d 00 20,3:
	bb 00 20 00 00          # movl   $0x2000,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [O]                  # call   OUTPUT
	/
# STX $2000  - write to $2000
8e 00 20,3:
	bb 00 20 00 00          # movl   $0x2000,%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [O]                  # call   OUTPUT
	86 c1                   # xchgb  %al,%cl
	/
# STY $2000  - write to $2000
8c 00 20,3:
	bb 00 20 00 00          # movl   $0x2000,%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [O]                  # call   OUTPUT
	86 c2                   # xchgb  %al,%dl
	/

# STA $2001  - write to $2001
8d 01 20,3:
	bb 01 20 00 00          # movl   $0x2001,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [O]                  # call   OUTPUT
	/
# STX $2001  - write to $2001
8e 01 20,3:
	bb 01 20 00 00          # movl   $0x2001,%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [O]                  # call   OUTPUT
	86 c1                   # xchgb  %al,%cl
	/
# STY $2001  - write to $2001
8c 01 20,3:
	bb 01 20 00 00          # movl   $0x2001,%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [O]                  # call   OUTPUT
	86 c2                   # xchgb  %al,%dl
	/

# STA $2002  - write to $2002?? should not happen
8d 02 20,3:
#	bb 02 20 00 00          # movl   $0x2002,%ebx
	83 c6 04                # addl   $4,%esi

#	e8 [O]                  # call   OUTPUT
	/

# STA $2003  - write to $2003
8d 03 20,3:
	bb 03 20 00 00          # movl   $0x2003,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [O]                  # call   OUTPUT
	/
# STX $2003  - write to $2003
8e 03 20,3:
	bb 03 20 00 00          # movl   $0x2003,%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [O]                  # call   OUTPUT
	86 c1                   # xchgb  %al,%cl
	/
# STY $2003  - write to $2003
8c 03 20,3:
	bb 03 20 00 00          # movl   $0x2003,%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [O]                  # call   OUTPUT
	86 c2                   # xchgb  %al,%dl
	/

# STA $2004  - write to $2004
8d 04 20,3:
	bb 04 20 00 00          # movl   $0x2004,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [O]                  # call   OUTPUT
	/
# STX $2004  - write to $2004
8e 04 20,3:
	bb 04 20 00 00          # movl   $0x2004,%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [O]                  # call   OUTPUT
	86 c1                   # xchgb  %al,%cl
	/
# STY $2004  - write to $2004
8c 04 20,3:
	bb 04 20 00 00          # movl   $0x2004,%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [O]                  # call   OUTPUT
	86 c2                   # xchgb  %al,%dl
	/

# STA $2005  - write to $2005
8d 05 20,3:
	bb 05 20 00 00          # movl   $0x2005,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [O]                  # call   OUTPUT
	/
# STX $2005  - write to $2005
8e 05 20,3:
	bb 05 20 00 00          # movl   $0x2005,%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [O]                  # call   OUTPUT
	86 c1                   # xchgb  %al,%cl
	/
# STY $2005  - write to $2005
8c 05 20,3:
	bb 05 20 00 00          # movl   $0x2005,%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [O]                  # call   OUTPUT
	86 c2                   # xchgb  %al,%dl
	/

# STA $2006  - write to $2006
8d 06 20,3:
	bb 06 20 00 00          # movl   $0x2006,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [O]                  # call   OUTPUT
	/
# STX $2006  - write to $2006
8e 06 20,3:
	bb 06 20 00 00          # movl   $0x2006,%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [O]                  # call   OUTPUT
	86 c1                   # xchgb  %al,%cl
	/
# STY $2006  - write to $2006
8c 06 20,3:
	bb 06 20 00 00          # movl   $0x2006,%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [O]                  # call   OUTPUT
	86 c2                   # xchgb  %al,%dl
	/

# STA $2007  - write to $2007
8d 07 20,3:
	bb 07 20 00 00          # movl   $0x2007,%ebx
	83 c6 04                # addl   $4,%esi

	e8 [O]                  # call   OUTPUT
	/
# STX $2007  - write to $2007
8e 07 20,3:
	bb 07 20 00 00          # movl   $0x2007,%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [O]                  # call   OUTPUT
	86 c1                   # xchgb  %al,%cl
	/
# STY $2007  - write to $2007
8c 07 20,3:
	bb 07 20 00 00          # movl   $0x2007,%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [O]                  # call   OUTPUT
	86 c2                   # xchgb  %al,%dl
	/

# STA $40xx - I/O write
8d 00/00 40,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 04                # addl   $4,%esi

	e8 [O]                  # call   OUTPUT
	/
# STX $40xx - I/O write
8e 00/00 40,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 04                # addl   $4,%esi

	86 c1                   # xchgb  %al,%cl
	e8 [O]                  # call   OUTPUT
	86 c1                   # xchgb  %al,%cl
	/
# STY $40xx - I/O write
8c 00/00 40,3:
	bb [W+1] 00 00          # movl   $[W+1],%ebx
	83 c6 04                # addl   $4,%esi

	86 c2                   # xchgb  %al,%dl
	e8 [O]                  # call   OUTPUT
	86 c2                   # xchgb  %al,%dl
	/


# Indexed output

# STA $40xx,X
9d 00/00 40,3:
	0f b6 d9                # movzbl %cl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 05                # addl   $5,%esi

	e8 [O]                  # call   OUTPUT
	/
# STA $40xx,Y
99 00/00 40,3:
	0f b6 da                # movzbl %dl,%ebx
	66 81 c3 [W+1]          # addw   $[W+1],%bx
	83 c6 05                # addl   $5,%esi

	e8 [O]                  # call   OUTPUT
	/
